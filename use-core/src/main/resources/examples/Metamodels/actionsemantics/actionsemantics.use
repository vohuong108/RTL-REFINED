-- $ProjectHeader: use 0.393 Wed, 16 May 2007 14:10:28 +0200 opti $

-- This file is intended to specify the actionsemantics model as defined in
-- in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez


-- $Id: actionsemantics.use 1.1 Thu, 06 Jul 2006 15:16:20 +0200 green $

-- issues to resolve:
-- - can't specify navigavibility

-- minor changes:

--    - all associations have a name

--    - renamed identifiers which are keywords in USE (e.g., association,
--    aggregate). Appended an underscore to these names.

--    - calls of additional (user-defined) operations with no arguments
--    contain parentheses '()'

--    - replaced occurrences of Boolean enumeration types by the real
--    Boolean type.


-- error categories:
--   MM-ERR: error in class diagram of UML metamodel

--   E0: not yet available in USE
--   E0.1: association class not available
--   E0.2: 0..1 association end as set
--   E1: Typo/Notation

--   E2: Inconsisteny
--   E2.1: Rolename defined but class name used in navigation
--   E2.2: Problem in Class diagram
--   E2.3: non-existing operation
--   E2.4: operator precedence requires parentheses

--   E3: Type checking
--   E3.1: return type of operation declared as set but operation returns bag
--   E3.2: elements of a subtype are selected but cast to subtype is missing 
--         in the following
--   E3.3: return type of operation declared as set but operation returns sequence
--   E3.4: type mismatch in operation call

--   E4: General
--   E4.1: expression has errors, fix not possible because intended meaning is unclear
--   E4.2: operations on scalar values applied to collection or vice versa
--   E4.3: ambiguous use of self
--   E4.4: unnecessary or strange check for undefinedness
--   E4.5: expression has errors, fix seems possible

-- informational:
--   I1.1: inserted an explicit collect
--   I1.2: use Set{...} or = in navigation to a single object
--   I1.3: inserted explicit flatten operation
--   I1.4: replaced Name type with String type
--   I1.5: reference to other package
--   I1.6: inserted element variable declaration in expr based on iterate
--   I1.7: replaced boolean enumeration literal
--   I1.8: reformulated expression

--model UML13All
model actionsemantics

enum AggregationKind { none, aggregate, composite }
enum ChangeableKind { changeable, frozen, addOnly }
enum CallConcurrencyKind { sequential, guarded, concurrent }
enum OrderingKind { unordered, ordered_ }
enum ParameterDirectionKind { in_, out, inout, return }
enum PseudoStateKind { choice, deepHistory, fork, initial,
                       join, junction, shallowHistory }
enum ScopeKind { instance, classifier }
enum VisibilityKind { public, protected, private }

--------------------------------------------------------------
-- enumeration types
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
enum ActionExecutionStatusType {waiting, ready, executing, complete}
enum ProcStatusType {proc_executing, proc_complete}
-- Package: Core

-- Fig. 2-5

abstract class Element
end

abstract class ModelElement < Element
attributes
  name : String
operations

-- [1] The operation supplier results in a Set containing all direct
-- suppliers of the ModelElement.

-- STATE: I1.1, I1.3, E3.1

  supplier() : Set(ModelElement) =
    self.clientDependency->collect(d : Dependency | d.supplier)->flatten->asSet

-- [2] The operation allSuppliers results in a Set containing all the
-- ModelElements that are suppliers of this ModelElement, including
-- the suppliers of these Model Elements. This is the transitive
-- closure.

-- STATE: E4.2: allSuppliers(), I1.1, I1.3

  allSuppliers() : Set(ModelElement) =
    self.supplier()->union(self.supplier()->collect(m : ModelElement |
      m.allSuppliers())->flatten)->asSet

-- [3] The operation model results in the set of Models to which the
-- ModelElement belongs.

-- FIXME: I1.5: refers to package model management

--   model() : Set(Model) =
--     self.namespace->union(self.namespace.allSurroundingNamespaces)
--       ->select( ns| ns.oclIsKindOf (Model))

-- [4] A ModelElement is a template when it has parameters.

-- STATE: E2.2: templateParameter may refer to ModelElement or Templateparameter class

  isTemplate() : Boolean =
    (self.templateParameter->notEmpty)

-- [5] A ModelElement is an instantiated template when it is related
-- to a template by a Binding relationship.

-- STATE: Ok, I1.6: d

  isInstantiated() : Boolean =
    self.clientDependency->select(d : Dependency | d.oclIsKindOf(Binding))->notEmpty

-- [6] The templateArguments are the arguments of an instantiated
-- template, which substitute for template parameters.

-- STATE: I1.6: d, I1.1, I1.3, E4.2, E3.1, E3.2

  templateArguments() : Set(ModelElement) =
    self.clientDependency->select(d : Dependency | d.oclIsKindOf(Binding))
      ->collect(d : Dependency | d.oclAsType(Binding).argument)->flatten->asSet
end

abstract class Feature < ModelElement
attributes
  ownerScope : ScopeKind
  visibility : VisibilityKind
end

abstract class Namespace < ModelElement
operations

-- [1] The operation contents results in a Set containing all
-- ModelElements contained by the Namespace.

-- STATE: E1, E4.1: illegal union construct

  contents() : Set(ModelElement) =
    self.ownedElement

-- [2] The operation allContents results in a Set containing all
-- ModelElements contained by the Namespace.

-- STATE: Ok

  allContents() : Set(ModelElement) =
    self.contents()

-- [3] The operation allVisibleElements results in a Set containing
-- all ModelElements visible outside of the Namespace.

-- STATE: Ok, E0.1: need association class ElementOwnership

  allVisibleElements() : Set(ModelElement) =
    self.allContents()

-- [4] The operation allSurroundingNamespaces results in a Set
-- containing all surrounding Namespaces.

-- STATE: Ok, I1.2

  allSurroundingNamespaces() : Set(Namespace) =
    self.namespace->union(self.namespace.allSurroundingNamespaces())
end

abstract class GeneralizableElement < ModelElement
attributes
  isRoot : Boolean
  isLeaf : Boolean
  isAbstract : Boolean
operations

-- [1] The operation parent returns a Set containing all direct
-- parents.

-- STATE: I1.1, E3.1

  parent() : Set(GeneralizableElement) =
    self.generalization->collect(g | g.parent)->asSet

-- [2] The operation allParents returns a Set containing all the
-- Generalizable Elements inherited by this GeneralizableElement (the
-- transitive closure), excluding the GeneralizableElement itself.

-- STATE: I1.1, I1.3, E3.1

  allParents() : Set(GeneralizableElement) =
    self.parent()->union(
      self.parent()->collect(g | g.allParents())->flatten)->asSet
end

class Parameter < ModelElement
attributes
  defaultValue : String    -- FIXME: Expression
  kind : ParameterDirectionKind
end

class Constraint < ModelElement
attributes
  body : String        -- FIXME: BooleanExpression
end

abstract class Classifier < Namespace, GeneralizableElement
operations

-- [1] The operation allFeatures results in a Set containing all
-- Features of the Classifier itself and all its inherited Features.

-- STATE: E3.4: feature is ordered, I1.1, I1.3

  allFeatures() : Set(Feature) =
    self.feature->asSet->union(
      self.parent()->collect(g | 
        g.oclAsType(Classifier).allFeatures())->flatten->asSet)

-- [2] The operation allOperations results in a Set containing all
-- Operations of the Classifier itself and all its inherited
-- Operations.

-- STATE: E3.2

  allOperations() : Set(Operation) =
    self.allFeatures()->select(f | f.oclIsKindOf(Operation))->collect(f |
      f.oclAsType(Operation))->asSet

-- [3] The operation allMethods results in a Set containing all
-- Methods of the Classifier itself and all its inherited Methods.

-- STATE: E1, E3.2

  allMethods() : Set(Method) =
    self.allFeatures()->select(f | f.oclIsKindOf(Method))->collect(f |
      f.oclAsType(Method))->asSet

-- [4] The operation allAttributes results in a Set containing all
-- Attributes of the Classifier itself and all its inherited
-- Attributes.

-- STATE: E1, E3.2

  allAttributes() : Set(Attribute) =
    self.allFeatures()->select(f | f.oclIsKindOf(Attribute))->collect(f |
      f.oclAsType(Attribute))->asSet

-- [5] The operation associations results in a Set containing all
-- Associations of the Classifier itself.

-- STATE: E1, I1.1

  associations() : Set(Association) =
    self.associationEnd->collect(ae : AssociationEnd | ae.association_)->asSet

-- [6] The operation allAssociations results in a Set containing all
-- Associations of the Classifier itself and all its inherited
-- Associations.

-- STATE: E1, I1.1, I1.3

  allAssociations() : Set(Association) =
    self.associations()->union(
      self.parent()->collect(g |
        g.oclAsType(Classifier).allAssociations())->flatten->asSet)

-- [7] The operation oppositeAssociationEnds results in a set of all
-- AssociationEnds that are opposite to the Classifier.

-- STATE: E1: self.associationm, size > 1 ?!, < vs. <>, E2.1: associationEnd vs. connection, E3.1, I1.3, E4.2: .size

  oppositeAssociationEnds() : Set(AssociationEnd) =
    self.associations()->select ( a | a.connection->select ( ae | 
      ae.type = self )->size = 1 )->collect ( a | 
        a.connection->select ( ae | ae.type <> self ) )->union
          ( self.associations()->select ( a | a.connection->select ( ae |
            ae.type = self )->size > 1 )->collect ( a | a.connection) )
              ->flatten->asSet

-- [8] The operation allOppositeAssociationEnds results in a set of
-- all AssociationEnds, including the inherited ones, that are
-- opposite to the Classifier.

-- STATE: Ok, I1.1, I1.3

  allOppositeAssociationEnds() : Set (AssociationEnd) =
    self.oppositeAssociationEnds()->union (
      self.parent()->collect(g |
        g.oclAsType(Classifier).allOppositeAssociationEnds())->flatten->asSet)

-- [9] The operation specification yields the set of Classifiers that
-- the current Classifier realizes.

-- STATE: I1.1, E4.2: oclIsKindOf, I1.5: stereotype is in package extension mechanism, E1: quotes

  specification() : Set(Classifier) =
    self.clientDependency->
      select(d | 
        d.oclIsKindOf(Abstraction) 
        and d.stereotype.name = 'realization'
        and d.supplier->forAll(m : ModelElement | m.oclIsKindOf(Classifier)))
      ->collect(d : Dependency | d.supplier)->flatten
      ->collect(m : ModelElement | m.oclAsType(Classifier))->asSet

-- [10] The operation allContents returns a Set containing all
-- ModelElements contained in the Classifier together with the
-- contents inherited from its parents.

-- STATE: Ok, E0.1: ElementOwnership

  allContents() : Set(ModelElement) =
--    self.contents->union(self.parent.allContents->select(e |
--      e.elementOwnership.visibility = #public or
--      e.elementOwnership.visibility = #protected))

      self.contents()->union(
        self.parent()->collect(g |
          g.oclAsType(Classifier).allContents())->flatten->asSet)

-- [11] The operation allDiscriminators results in a Set containing
-- all Discriminators of the Gen-eralizations from which the
-- Classifier is descended itself and all its inherited Features.

-- STATE: Ok, I1.4, I1.1, I1.3

  allDiscriminators() : Set(String) =
    self.generalization->collect(g | g.discriminator)->union(
      self.parent()->collect(g |
        g.oclAsType(Classifier).allDiscriminators())->flatten)->asSet

end

abstract class StructuralFeature < Feature
attributes
--  multiplicity : String    -- FIXME: Multiplicity
  multiplicity : Multiplicity
  changeability : ChangeableKind
  targetScope : ScopeKind
end

abstract class BehavioralFeature < Feature
attributes
  isQuery : Boolean
operations

-- [1] The operation hasSameSignature checks if the argument has the
-- same signature as the instance itself.

-- STATE: Ok

  hasSameSignature(b : BehavioralFeature) : Boolean =
    (self.name = b.name) and
    (self.parameter->size = b.parameter->size) and
    Sequence{ 1..(self.parameter->size) }->forAll(index : Integer |
      b.parameter->at(index).type =
        self.parameter->at(index).type and
      b.parameter->at(index).kind =
        self.parameter->at(index).kind
    )

-- [2] The operation matchesSignature checks if the argument has a
-- signature that would clash with the signature of the instance
-- itself (and therefore must be unique). Mismatches in kind or any
-- differences in return parameters do not cause a mismatch:

-- STATE: E1 missing # before return

  matchesSignature(b : BehavioralFeature) : Boolean =
    (self.name = b.name) and
    (self.parameter->size = b.parameter->size) and
    Sequence{ 1..(self.parameter->size) }->forAll(index : Integer |
      b.parameter->at(index).type =
        self.parameter->at(index).type or
      (b.parameter->at(index).kind = #return and
        self.parameter->at(index).kind = #return)
    )
end

class Attribute < StructuralFeature
attributes
  initialValue : String    -- FIXME: Expression
end

class Operation < BehavioralFeature
attributes
  concurrency : CallConcurrencyKind
  isRoot : Boolean
  isLeaf : Boolean
  isAbstract : Boolean
  specification : String
end

class Method < BehavioralFeature
attributes
  body : String        -- FIXME: ProcedureExpression
end

-- Fig. 2-6

abstract class Relationship < ModelElement
end

class Flow < Relationship
end

class Generalization < Relationship
attributes
  discriminator : String
end

class AssociationEnd < ModelElement
attributes
  isNavigable : Boolean
  ordering : OrderingKind
  aggregation_ : AggregationKind
  targetScope : ScopeKind
  multiplicity : String    -- FIXME: Multiplicity
  changeability : ChangeableKind
  visibility : VisibilityKind
end

class Association < Relationship, GeneralizableElement
operations

-- [1] The operation allConnections results in the set of all
-- AssociationEnds of the Association.

-- STATE: E3.3

  allConnections() : Set(AssociationEnd) =
    self.connection->asSet

end

class Class < Classifier
attributes
  isActive : Boolean
end

class AssociationClass < Class, Association
operations

-- [1] The operation allConnections results in the set of all
-- AssociationEnds of the AssociationClass, including all connections
-- defined by its parent (transitive closure).

-- STATE: E2: self.connection results in a sequence, union(Seq,Bag) does not exist, E3.2: collect, I1.3

  allConnections() : Set(AssociationEnd) =
    self.connection->asBag->union(self.parent()->select
      (s | s.oclIsKindOf(Association))->collect (g : GeneralizableElement |
        g.oclAsType(Association).allConnections())->flatten)->asSet
end

-- Fig. 2-7

class Dependency < Relationship
end

class Binding < Dependency
end

class Abstraction < Dependency
attributes
  mapping : String     -- FIXME: MappingExpression
end

class Usage < Dependency
end

class Permission < Dependency
end

-- Fig. 2-8

class Interface < Classifier
end

class DataType < Classifier
end

class Node < Classifier
end

class Component < Classifier
operations

-- [1] The operation allResidentElements results in a Set containing
-- all ModelElements resident in a Component or one of its ancestors.

-- STATE: E1: set, E4.2: parent, E0.1: elementResidence, E2.2: Fig. 2-8 ElementResidence vs. Element

  allResidentElements() : Set(ModelElement) =
    self.resident->union(
      self.parent()->collect(g |
      g.oclAsType(Component).allResidentElements()->select( re |
--         re.elementResidence.visibility = #public or
--         re.elementResidence.visibility = #protected
    true
      ))->flatten)->asSet

-- [2] The operation allVisibleElements results in a Set containing
-- all ModelElements visible out-side the Component.

-- STATE: E0.1, E1: ->, superflous )

  allVisibleElements() : Set(ModelElement) =
    self.allContents()->union (
        self.allResidentElements())

--   allVisibleElements() : Set(ModelElement) =
--     self.allContents()->select( e |
--       e.elementOwnership.visibility = #public)->union (
--         self.allResidentElements()->select ( re |
--             re.elementResidence.visibility = #public))

end

-- Fig. 2-9

class Comment < ModelElement
end

abstract class PresentationElement < Element
end

-- Fig. 2-10

class TaggedValue
attributes
  tag : String
  value : String
end

class Stereotype < GeneralizableElement
attributes
  icon : String        -- originally: Geometry
  baseClass : String
end

-- Fig. 2-14

class Signal < Classifier
end

class Exception < Signal
end

class Reception < BehavioralFeature
attributes
  specification : String
  isRoot : Boolean
  isLeaf : Boolean
  isAbstract : Boolean
end

-- Fig. 2-15

class ActionSequence < Action
end

-- MM-ERR: Model -> ModelElement
abstract class Action < ModelElement
attributes
  recurrence : String      -- FIXME: need datatypes
  target : String      -- FIXME: need datatypes
  isAsynchronous : Boolean
  script : String      -- FIXME: need datatypes
end

class Argument
attributes
  value : String       -- FIXME: need datatypes
end

class CreateAction < Action
end

class CallAction < Action
end

class ReturnAction < Action
end

class SendAction < Action
end

class TerminateAction < Action
end

class UninterpretedAction < Action
end

class DestroyAction < Action
end

-- Fig. 2-16

class AttributeLink < ModelElement
end

class Stimulus < ModelElement
end

class Link < ModelElement
end

class LinkEnd < ModelElement
end

class Instance < ModelElement
operations

-- [1] The operation allLinks results in a set containing all Links of
-- the Instance itself.

--  allLinks : set(Link) allLinks = self.linkEnd.link

-- STATE: E1: set, E3.1, I1.1

  allLinks() : Set(Link) =
    self.linkEnd->collect(le | le.link)->asSet

-- [2] The operation allOppositeLinkEnds results in a set containing
-- all LinkEnds of Links connected to the Instance with another
-- LinkEnd.

-- STATE: E1: set, E3.1, I1.1

  allOppositeLinkEnds() : Set(LinkEnd) =
    self.allLinks()->collect(l | l.connection->select (le |
      le.instance <> self))->flatten->asSet

-- [3] The operation selectedLinkEnds results in a set containing all
-- opposite LinkEnds corresponding to a given AssociationEnd.

-- STATE: E1: set

  selectedLinkEnds(ae : AssociationEnd) : Set(LinkEnd) =
    self.allOppositeLinkEnds()->select (le | le.associationEnd = ae)

-- [4] The operation selectedAttributeLinks results in a set
-- containing all AttributeLinks corresponding to a given Attribute.

-- STATE: Ok

  selectedAttributeLinks(a : Attribute) : Set(AttributeLink) =
    self.slot->select (s | s.attribute = a)

end

class DataValue < Instance
end

class ComponentInstance < Instance
end

class NodeInstance < Instance
end

class Object < Instance
end

class LinkObject < Instance, Link
end

-- Fig. 2-17 Collaborations

class Collaboration < GeneralizableElement, Namespace
operations

-- [1] The operation allContents results in the set of all
-- ModelElements contained in the Collaboration together with those
-- contained in the parents except those that have been specialized.

-- STATE: E1: include, E3.1, E3.2
  allContents() : Set(ModelElement) =
    self.contents()->union (
      self.parent()->collect(g |
        g.oclAsType(Collaboration).allContents())->flatten->reject ( e |
          self.contents()->collect(me | me.name)->includes (e.name) ))->asSet
end

class AssociationRole < Association
attributes
  multiplicity : String    -- FIXME: Multiplicity
end

class AssociationEndRole < AssociationEnd
attributes
  collaborationMultiplicity : String   -- FIXME: Multiplicity
end

class ClassifierRole < Classifier
attributes
  multiplicity : String    -- FIXME: Multiplicity
operations

-- [1] The operation allAvailableFeatures results in the set of all
-- Features contained in the ClassifierRole together with those
-- contained in the parents.

-- STATE: E3.1, E3.2, I1.1

  allAvailableFeatures() : Set(Feature) =
    self.availableFeature->union(
      self.parent()->collect(g |
        g.oclAsType(ClassifierRole).allAvailableFeatures())->flatten)->asSet

-- [2] The operation allAvailableContents results in the set of all
-- ModelElements contained in the ClassifierRole together with those
-- contained in the parents.

-- STATE: E3.1, E3.2, I1.1

  allAvailableContents() : Set(ModelElement) =
    self.availableContents->union(
      self.parent()->collect(g |
        g.oclAsType(ClassifierRole).allAvailableContents())->flatten)->asSet
end

class Message < ModelElement
operations

-- [1] The operation allPredecessors results in the set of all
-- Messages that precede the current one.

-- STATE: E3.1, I1.1, I1.3

  allPredecessors() : Set(Message) =
    self.predecessor->union(
      self.predecessor->collect(m | m.allPredecessors())->flatten)->asSet
end

class Interaction < ModelElement
end


-- Fig. 2-18 Use Cases

class Actor < Classifier
end

class UseCase < Classifier
operations

-- [1] The operation specificationPath results in a set containing all
-- surrounding Namespaces that are not instances of Package.

-- STATE: Ok

  specificationPath() : Set(Namespace) =
    self.allSurroundingNamespaces()->select(n |
      n.oclIsKindOf(Subsystem) or
      n.oclIsKindOf(Class))

-- [2] The operation allExtensionPoints results in a set containing
-- all ExtensionPoints of the UseCase.

-- STATE: E2.3: allSupertypes, E3.2, I1.1, I1.3

  allExtensionPoints() : Set(ExtensionPoint) =
    self.allParents()->collect(c | c.oclAsType(UseCase).extensionPoint)
      ->flatten->asSet-> union ( self.extensionPoint)
end

class UseCaseInstance < Instance
end

class ExtensionPoint < ModelElement
attributes
  location : String        -- FIXME: LocationReference
end

class Include < Relationship
end

class Extend < Relationship
attributes
  condition : String       -- FIXME: BooleanExpression
end


-- Fig. 2-21, 2-22 State Machines

class StateMachine < ModelElement
operations
--------------------------------------------------------------
-- aditional operations for state machine
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- operations
--------------------------------------------------------------
allTransitions():Set(Transition) =
  self.transition->union(self.allStates()->collect(s:State|s.internal)->asSet->flatten)
allStates():Set(State) =
  self.top.allSubstates()->iterate(sv:StateVertex;acc:Set(State) = oclEmpty(Set(State))|
                                   acc->including(sv.oclAsType(State)))->including(self.top)
end

class Guard < ModelElement
attributes
  expression : String      -- FIXME: BooleanExpression
end

class Transition < ModelElement
end

abstract class StateVertex < ModelElement
--------------------------------------------------------------
-- aditional operations for state vertex
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- operations
--------------------------------------------------------------
operations
allSubstates():Set(StateVertex) =
  if self.oclIsKindOf(CompositeState) then
    self.oclAsType(CompositeState).subvertex->union(
      self.oclAsType(CompositeState).subvertex ->
        collect(s:StateVertex|s.allSubstates())->asSet->flatten)
  else
    oclEmpty(Set(StateVertex))
  endif
end

-- MM-ERR: Typo
class PseudoState < StateVertex
attributes
  kind : PseudoStateKind
end

class SynchState < StateVertex
attributes
  bound : Integer      -- FIXME: UnlimitedInteger
end

class StubState < StateVertex
attributes
  referenceState : String
end

abstract class State < StateVertex
end

class CompositeState < State
attributes
  isConcurrent : Boolean
end

class SimpleState < State
end

class FinalState < State
end

class SubmachineState < CompositeState
end

abstract class Event < ModelElement
end

class SignalEvent < Event
end

class CallEvent < Event
end

class TimeEvent < Event
attributes
  when : String        -- FIXME: TimeExpression
end

class ChangeEvent < Event
attributes
  changeExpression : String    -- FIXME: BooleanExpression
end


-- Fig. 2-28, Activity Graphs

class ActivityGraph < StateMachine
end

class Partition < ModelElement
end

class SubactivityState < SubmachineState
attributes
  isDynamic : Boolean
  dynamicArguments : String    -- FIXME: ArgListsExpression
  dynamicMultiplicity : String -- FIXME: Multiplicity
end

class ActionState < SimpleState
attributes
  isDynamic : Boolean
  dynamicArguments : String    -- FIXME: ArgListsExpression
  dynamicMultiplicity : String -- FIXME: Multiplicity
end

class CallState < ActionState
end

class ObjectFlowState < SimpleState
attributes
  isSynch : Boolean
operations

-- [1] Parameters of an object flow state must have a type and
-- direction compatible with classifier or classifier-in-state of the
-- object flow state.

-- STATE: E1: isKindOf, missing endif, E3.2

  osftype() : Classifier =
    if self.type.oclIsKindOf(ClassifierInState) then
      self.type.oclAsType(ClassifierInState).type
    else
      self.type
    endif
end

class ClassifierInState < Classifier
end


-- Fig. 2-29, Model Management

class Package < Namespace, GeneralizableElement
operations

-- [1] The operation contents results in a Set containing the
-- ModelElements owned by or imported by the Package.

-- STATE: Ok

  contents() : Set(ModelElement) =
    self.ownedElement->union(self.importedElement)

-- [2] The operation allImportedElements results in a Set containing
-- the Model Elements imported by the Package or one of its
-- supertypes.

-- STATE: E0.1

--   allImportedElements() : Set(ModelElement) =
--     self.importedElement->union(
--       self.supertype.oclAsType(Package).allImportedElements->select( re |
--         re.elementImport.visibility = #public or
--         re.elementImport.visibility = #protected))

-- [3] The operation allContents results in a Set containing the
-- ModelElements owned by or imported by the Package or one of its
-- ancestors.

-- STATE: E0.1

--   allContents() : Set(ModelElement) =
--     self.contents->union(
--       self.parent.allContents->select(e |
--         e.elementOwnership.visibility = #public or
--         e.elementOwnership.visibility = #protected))
end

class Subsystem < Classifier, Package
attributes
  isInstantiable : Boolean
operations

-- [1] The operation allSpecificationElements results in a Set
-- containing the Model Elements specifying the behavior of the
-- Subsystem.

-- STATE: E0.1: need association class ElementOwnership

--   allSpecificationElements() : Set(ModelElement) =
--     self.allContents()->select(c | c.elementOwnership.isSpecification )

-- [2] The operation contents results in a Set containing the
-- ModelElements owned by or imported by the Subsystem.

-- STATE: Ok, duplicates operation in Package?!

  contents() : Set(ModelElement) =
    self.ownedElement->union(self.importedElement)
end

class Model < Package
end

--------------------------------------------------------------
-- package Identity_and_snapshot
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------


--------------------------------------------------------------
-- Note:

-- Description of a Class

-- Attributes. This section lists all attributes of the class,
-- including their types and multiplicity.
-- For enumerations, a list of enumeration literals follows, one to a line.

-- Associations. This section lists all associations that have end names
-- opposite from the class being described.

-- Well-formedness Rules. This section lists constraints on the model.
-- The constraints cover aspects not already expressed in the model ,
-- such as association multi-plicity.

-- Additional Operations. This section defines, in OCL, additional
-- operations that apply to the class.

-- Execution Rules. The dynamic semantics of a behavioral element is captured
-- by execution rules that determine the effects of the steps between execution
-- snapshots for the element.

-- Inputs. This section list the inputs pins required for an action,
-- in terms of these derived associations.

-- Outputs. This subsection lists the output pins using the same format as input pins.

-- Execution Semantics. In the case of most simple, primitive actions,
-- rather than providing a separate snapshot description to simply list
-- the productions, this listing can be included with the description of
-- the action metaclass itself, in this "Execution Semantics" section.
--------------------------------------------------------------

--------------------------------------------------------------
-- NOTE: All new clases defined will specialize class Class
--       unless stated otherwise.
--------------------------------------------------------------

abstract class Snapshot < Class
attributes
operations
-- [1] This operation returns the set of predecessors of this snapshot
-- (which will always be a singleton or the empty set).
  predecessor() : Set(Snapshot) =
    Set{self.preChange.predecessor}
-- [2] This operation returns the set of successors of this snapshot
-- (which will always be a singleton or the empty set).
  successor() : Set(Snapshot) =
    Set{self.postChange.successor}
-- [3] This operation asserts that this is the first snapshot
-- in its history.
  isNew() : Boolean =
    self.predecessor()->isEmpty()
-- [4] This operation asserts that this is last snapshot in its history.
  terminates() : Boolean =
     self.successor()->isEmpty()
end

abstract class Identity < Class
attributes
operations
end

class Change < Class
attributes
    time: Integer
operations
end

class History < Class
attributes
operations
end

--------------------------------------------------------------
-- package execution dynamics fundamentals
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------
class ExecutionSnapshot < Snapshot
attributes
operations
-- [1] This operation returns the current referent snapshot
-- for the given identity.
  current(id : Identity) : Snapshot =
    self.referent->select(s:Snapshot|s.identity = id)->
                          iterate(v; result : Snapshot = oclUndefined(Snapshot) | v)

-- [2] This operation returns the referent snapshot for the given identity
-- relative to the preceding execution snapshot.
   _pre(id : Identity) : Snapshot =
-- pre: not self.isNew()
    self.preChange.predecessor.oclAsType(ExecutionSnapshot).current(id)
-- post: result = self.predecessor().oclAsType(ExecutionSnapshot).current(id)

-- [3] This operation returns the snapshot for the given identity that is the
-- result of a change caused by the step preceding this execution snapshot.
   _post(id : Identity) : Snapshot =
     self.preChange.oclAsType(Step).effect->collect(c:Change|c.successor)->
          asSet->select(s:Snapshot|s.identity = id)->
                        iterate(v; result : Snapshot = oclUndefined(Snapshot) | v)
-- post: self.preChange.oclAsType(Step).effect.successor->includes(result)
--       and result.identity = id

-- [4] This operation asserts that the step preceding this execution snapshot
-- caused the creation of the entity with given identity.
  new_(id : Identity) : Boolean =
    self.preChange.oclAsType(Step).predecessor.isDefined()
--    Set{self.preChange.oclAsType(Step).predecessor}->notEmpty
-- post: self.post(id).isNew()

-- [5] This operation asserts that the step proceeding this execution
-- snapshot caused the destruction of the entity with given identity.
  destroyed(id : Identity) : Boolean =
    self.preChange.oclAsType(Step).effect->exists(c : Change |
    c.successor.isDefined() and c.predecessor.identity = id)
end

class Step < Change
attributes
operations
end

--------------------------------------------------------------
-- package instance
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

abstract class InstanceIdentity < Identity
attributes
operations
end

class LinkIdentity < Identity
attributes
operations
end

class DataValueIdentity < InstanceIdentity
attributes
operations
end

class ObjectIdentity < InstanceIdentity
attributes
operations
end

--------------------------------------------------------------
-- package object execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class AttributeValue
attributes
operations
-- [1] This operation returns the position, as a positive integer, of an attribute
-- value in the sequence of attribute values for an ordered attribute.
  at() : Integer =
    if self.predecessor.isUndefined() then
      1
    else
      self.predecessor.at() + 1
    endif
end

abstract class ObjectSnapshot < Snapshot
attributes
operations
end

--------------------------------------------------------------
-- package link execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class LinkEndValue
attributes
operations
-- [1] This operation returns the position, as a positive integer, of a link-end value
-- in the sequence of link-end values for an ordered association end.
--  at() : Integer =
--    if self.predecessor.isUndefined() then
--      1
--    else
--      self.predecessor.at() + 1
--    endif
end

class LinkSnapshot < Snapshot
attributes
operations
end

--------------------------------------------------------------
-- package link objects
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class LinkObjectIdentity < LinkIdentity, ObjectIdentity
attributes
operations
end

class LinkObjectSnapshot < LinkSnapshot, ObjectSnapshot
attributes
operations
end

class NonLinkObjectSnapshot < ObjectSnapshot
attributes
operations
end

--------------------------------------------------------------
-- package classifier extent
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class ClassifierExtentIdentity < Identity
attributes
operations
end

class ClassifierExtentSnapshot < Snapshot
attributes
operations
end

--------------------------------------------------------------
-- package association extent
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class AssociationExtentIdentity < Identity
attributes
operations
end

class AssociationExtentSnapshot < Snapshot
attributes
operations
end

--------------------------------------------------------------
-- package state machine execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class StateMachineExecutionIdentity < Identity
attributes
operations
end

class StateMachineExecutionSnapshot < Snapshot
attributes
operations
end

--------------------------------------------------------------
-- package occurrence
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

abstract class Occurrence
attributes
operations
end

class SignalOccurrence < Occurrence
attributes
operations
end

class ChangeOccurrence < Occurrence
attributes
operations
end

class TimeOccurrence < Occurrence
attributes
operations
end

--------------------------------------------------------------
-- package action foundation
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

--------------------------------------------------------------
-- Classes Multiplicity and MultiplicityRange
-- Modeled in order to be able to define DataFlow
-- after definition in Response to OMG RFP ad/98-11-01
--------------------------------------------------------------

class Multiplicity < Class
operations
-- [1] This operation checks if a given integer cardiniality is allowed by a multiplicity.
  allows(i : Integer) : Boolean =
    self.range->exists(r : MultiplicityRange | r.contains(i))
-- [2] This operation checks if one multiplicity is compatible with another.
  compatibleWith(other : Multiplicity) : Boolean =
--    Integer.allInstances->forAll(i : Integer | self.allows(i) implies other.allows(i))
-- FIXME: This is not the right definition for compatibleWith,
-- but Integer.allInstances is not allowed.
    other.range->forAll(omr: MultiplicityRange| self.range->exists(smr:MultiplicityRange |
      smr.containsRange(omr)))
end

class MultiplicityRange < Class
attributes
  unlimited: Boolean
  upper: Integer
  lower: Integer
operations
-- [1] This operation checks if a given integer is within the range specified
-- by a multiplicity range.
  contains(i : Integer) : Boolean =
    if (self.unlimited) then
      self.lower <= i
    else
      self.lower<=i and i<=self.upper
    endif
-- [1] This operation checks if a given MultiplicityRange is within the range specified
-- by this multiplicity range. Defined by Jose Alvarez to define Multiplicity::compatibleWith
  containsRange(mr: MultiplicityRange) : Boolean =
    if (self.unlimited) then
      self.lower <= mr.lower
    else
      self.lower<=mr.lower and mr.upper<=self.upper
    endif

end

abstract class Action_ < ModelElement
attributes
operations
-- [1] This operation returns the set of all immediately nested actions of this action.
-- FIXME: This operation is not defined for class Action_ in the submission.
  nestedActions() : Set(Action_) =
      oclUndefined(Set(Action_))
-- [2] This operation returns all nested actions of an action, nested to any depth.
  allNestedActions() : Set(Action_) =
    self.nestedActions()->union(self.nestedActions()->
      collect(a:Action_| a.allNestedActions())->flatten->asSet)
-- [3] This operation returns the set of immediate subactions of this action, whose output
-- pins may be directly connected to the input pins of actions outside this action
-- FIXME: This operation is not defined for class _Action in the submission.
    subactions() : Set(Action_) =
      oclUndefined(Set(Action_))
-- [4] This operation returns all subactions of an action, nested to any depth.
  allSubactions() : Set(Action_) =
    self.subactions()->union(self.subactions()->
      collect(a:Action_| a.allSubactions())->flatten->asSet)
-- [5] This operation returns the set of all input and output pins of an action.
--  allPins() : Set(Pin) =
-- FIXME: Target type 'Pin' is not a subtype of the source expression's type 'InputPin'.
--    self.inputPin->collect(i:InputPin|i.oclAsType(Pin))->asSet->
--      union(self.outputPin->collect(o:OutputPin|o.oclAsType(Pin))->asSet)
-- [6] This operation returns true if the action is a subaction, at any depth,
-- of another given action.
  isSubaction(otherAction: Action_):Boolean =
    otherAction.allSubactions()->includes(self)
-- [7] This operation returns the set of actions whose execution must complete before
-- this action can execute
  prerequisites() : Set(Action_) =
    self.inputPin->collect(i:InputPin | i.flow.source.action)->asSet->
      union(self.antecedant->collect(c:ControlFlow|c.predecessor)->asSet)
-- [8] This operation returns all the actions which are destinations of data flows or
-- successors of control flows leaving an action
  successors() : Set(Action_) =
    self.outputPin->collect(o:OutputPin | o.flow->
      collect(d:DataFlow| d.destination.action)->asSet)->asSet->flatten->
        union((self.consequent->collect(cf:ControlFlow|cf.successor)->asSet)->
          union(self.group.consequent->collect(cf:ControlFlow|cf.successor)))->
            collect(a : Action_ | a.subactions()->including(a))->flatten->asSet()
--    self.outputPin->collect(o:OutputPin | o.flow->
--      collect(d:DataFlow| d.destination.action)->asSet)->flatten->asSet->
--        union((self.consequent->collect(c:ControlFlow|c.successor)))->asSet
--        ->union(self.group.consequent.successor))->
--          collect(a : Action_ | a.subactions()->including(a)))->asSet()
-- [9] This operation returns the transitive closure of all data-flow and
-- control-flow successors
  allSuccessors() : Set(Action_) =
    self.successors()->union(self.successors()->
      collect(a:Action_| a.allSuccessors())->flatten->asSet)
end

class PrimitiveAction < Action_
attributes
operations
-- [1] A primitive action has no subactions.
  subactions() : Set(Action_) =
    oclEmpty(Set(Action_))
end

class ControlFlow < ModelElement
attributes
operations
end

class DataFlow < ModelElement
attributes
operations

end

class Pin < ModelElement
attributes
  multiplicity : Multiplicity
  ordering : OrderingKind
operations

end

class InputPin < Pin
attributes
operations
end

class OutputPin < Pin
attributes
operations
end

class Procedure < ModelElement
attributes
operations
end

--------------------------------------------------------------
-- package action foundation execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------
class ActionExecutionIdentity < Identity
attributes
operations
-- [1] This operation returns the procedure execution within which
-- this action execution is ultimately nested.
-- FIXME: Undefined operation named `proceduralExecution' in expression
-- `Set(GeneralizableElement).proceduralExecution()'.
-- In first place is procedureExecution() instead of proceduralExecution().
-- As well as that, I am afraid that the problem here is that self.parent is
-- supossed to return the parent action of the current action and it returns
-- the set of all direct parent classes.

  procedureExecution() : ProcedureExecutionIdentity =
    if self.proceduralContext.isDefined() then
      self.proceduralContext
    else
--      self.parent.procedureExecution()
      self._context.procedureExecution()
    endif
end

-- abstract class ActionExecutionSnapshot < ExecutionSnapshot
class ActionExecutionSnapshot < ExecutionSnapshot
attributes
  status: ActionExecutionStatusType
operations
-- [1] This operation returns the identity of the host instance for this action execution.
  host() : InstanceIdentity =
    self.executionID.procedureExecution().host
-- [2] This operation returns the set of identities of action executions nested in this action
-- execution that are available to act as prerequisites of other action executions.
   availableExecutions() : Set(ActionExecutionIdentity) =
-- FIXME: This operation is not defined for class ActionExecutionSnapshot in the submission.
    oclUndefined(Set(ActionExecutionIdentity))
-- [3] This operation returns the set of execution identities of currently executing
-- actions that may act as prerequisites to this one.
-- FIXME: Expression type `Set(ActionExecutionIdentity)' does not
-- match declared result type 'ActionExecutionSnapshot'.
  peerExecutions() : Set(ActionExecutionIdentity) =
    if not self.executionID._context.isDefined() then
--      self
        Set{self.executionID}
    else
      self.current(self.executionID._context).oclAsType(ActionExecutionSnapshot).peerExecutions()->
      union(self.current(self.executionID._context).oclAsType(ActionExecutionSnapshot).
      availableExecutions())
    endif
-- [4] This operation returns the identity of the current execution of the given action.
-- FIXME: Expression type `Set(ActionExecutionIdentity)' does not match
-- declared result type `ActionExecutionIdentity'.
  executionOf(a: Action_) : ActionExecutionIdentity =
    self.peerExecutions()->select(aei: ActionExecutionIdentity| aei.action=a)->
        iterate(aei; result : ActionExecutionIdentity = oclUndefined(ActionExecutionIdentity)| aei)
-- [5] This operation returns the current action-execution snapshot for a given action.
  currentSnapshotOf(a : Action_) : ActionExecutionSnapshot =
    self.current(self.executionOf(a)).oclAsType(ActionExecutionSnapshot)
-- [6] This operation returns the value of a given pin for this snapshot.
  valueOf(p : Pin) : OrderedSet(InstanceIdentity) =
    self.pinValue->select(pv:PinValue|pv.pin=p)->
      iterate(p;acc:PinValue = oclUndefined(PinValue)|p).value
-- [7] This operation returns the source value for a given input pin.
-- FIXME: 'valueOf' function not defined for ProcedureExecutionSnapshot
--  sourceValueFor(p : InputPin) : Sequence(InstanceIdentity) =
--      if p.flow.source.action.isDefined() then
--        self.currentSnapshotOf(p.flow.source.action).valueOf(p.flow.source)
--      else
--        self.current(self.executionID.procedureExecution()).oclAsType(ProcedureExecutionSnapshot).
--        valueOf(p.flow.source)
--      endif
-- [8] This operation checks that the input-pin values of this snapshot have
-- not changed from the previous snapshot.
-- FIXME: Undefined operation named `pin' in expression `Set(PinValue).pin()'.
-- FIXME: The tool blocks when compiling this operation
--  inputValuesUnchanged() : Boolean =
--        self.pinValue->select(pv:PinValue|pv.pin.oclIsTypeOf(InputPin))->
--                              collect(pv:PinValue| pv.pin) =
-- FIXME: Target type `ActionExecutionSnapshot' is not a subtype of the source expression's type `Set(Snapshot)'.
--        self.predecessor().oclAsType(ActionExecutionSnapshot).pinValue->
--        self.predecessor()->iterate(aes;acc:ActionExecutionSnapshot =
--          oclUndefined(ActionExecutionSnapshot)| aes).
--            oclAsType(ActionExecutionSnapshot).pinValue->
--              select(pv:PinValue|pv.pin.oclIsTypeOf(InputPin))->collect(pv:PinValue| pv.pin) and
--        self.pinValue->select(pv:PinValue|pv.pin.oclIsTypeOf(InputPin))->
--                              collect(pv:PinValue| pv.value) =
--        self.predecessor().oclAsType(ActionExecutionSnapshot).pinValue->
--          select(pv:PinValue|pv.pin.oclIsType(InputPin))->
--                              collect(pv:PinValue| pv.value)
-- [9] This operation returns the value of an output pin of the action being executed,
-- identified by index.
  pinValueAt(i : Integer) : OrderedSet(InstanceIdentity)=
    self.valueOf(self.executionID.action.outputPin->at(i))
-- [10] This operation asserts that the current snapshot of the given action-execution
-- identity has status complete.
  completed(e : ActionExecutionIdentity) : Boolean =
    self.current(e).oclAsType(ActionExecutionSnapshot).status = #complete
end

class PinValue
attributes
operations
end

class PrimitiveActionExecutionIdentity < ActionExecutionIdentity
attributes
operations
end

class ProcedureExecutionIdentity < Identity
attributes
operations
end

class ProcedureExecutionSnapshot < ExecutionSnapshot
attributes
  status: ProcStatusType
operations
-- [1] This operation returns the current snapshot of the action executed by the procedure.
  currentActionSnapshot() : ActionExecutionSnapshot =
    self.current(self.executionID.actionExecution).oclAsType(ActionExecutionSnapshot)
-- [2] This operation returns the value of a given pin for this procedure-execution snapshot.
-- FIXME:  Expression type `Set(PinValue)' does not match declared result type `Sequence(InstanceIdentity)'.
  valueOf(p : Pin) : OrderedSet(InstanceIdentity) =
    self.pinValue->select(pv:PinValue|pv.pin=p)->
      iterate(p;acc:PinValue = oclUndefined(PinValue)|p).value

-- [3] This operation returns the source value for a given result pin (as a "pre" value).
   sourceValueFor(p : InputPin) : OrderedSet(InstanceIdentity) =
     self.currentActionSnapshot().valueOf(p.flow.source)
-- [4] This operation asserts that the execution of the procedure action has been started.
  actionExecutionStarted(): Boolean =
    self.new_(self.executionID.actionExecution)
end

--------------------------------------------------------------
-- package composite actions
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class GroupAction < Action_
attributes
  isIsolated: Boolean
operations
-- [1] The nested actions of a group action are its subactions.
  nestedActions() : Set(Action_) =
    self.subaction
-- [2] A group action has explicit subactions.
  subactions_() : Set(Action_) =
    self.subaction
end

class Variable
attributes
  multiplicity: Multiplicity
  ordering: OrderingKind
operations
-- [1] This operations checks whether the given action is within the scope of this variable.
  isAccessibleBy(a : Action_) : Boolean =
    self.scope.nestedActions()->includes(a)
end

--------------------------------------------------------------
-- package composite action execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class GroupExecutionIdentity < ActionExecutionIdentity
attributes
operations
end

class GroupExecutionSnapshot < ActionExecutionSnapshot
attributes
operations
-- [1] The available executions of a group-execution snapshot
-- include all subaction executions and all their available executions.
-- FIXME: Undefined operation 'availableExecutions' in 'ActionExecutionIdentity.availableExecutions()'.
--  availableExecutions() : Set(ActionExecutionIdentity) =
--    self.groupExecutionID.subactionExecution->union(
--      self.groupExecutionID.subactionExecution->collect(aei:ActionExecutionIdentity|
--                                                        aei.availableExecutions())->asSet())
--      self.groupExecutionID.subactionExecution.availableExecutions()->asSet())
-- [2] This operation asserts that the subaction executions have been started.
  subactionExecutionsStarted() : Boolean =
    self.groupExecutionID.subactionExecution->forAll(e : ActionExecutionIdentity | self.new_(e))
-- [3] This operation asserts that the subaction executions have completed.
  subactionExecutionsCompleted() : Boolean =
    self.groupExecutionID.subactionExecution->forAll(e : ActionExecutionIdentity | self.completed(e))
-- [4] This operation asserts that the variable executions have been started.
  variableExecutionsStarted() : Boolean =
    self.groupExecutionID.variableExecution->forAll(e : VariableExecutionIdentity | self.new_(e))
-- [5] This operation asserts that the variable executions have been stopped.
  variableExecutionStopped() : Boolean =
    self.groupExecutionID.variableExecution->forAll(e : VariableExecutionIdentity | self.destroyed(e))
end

class VariableExecutionIdentity < Identity
attributes
operations
end

class VariableExecutionSnapshot < ExecutionSnapshot
attributes
operations
end

--------------------------------------------------------------
-- package Read and Write actions. Variable actions
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

abstract class VariableAction < Action_
attributes
operations
end

class ReadVariableAction < VariableAction
attributes
operations
end

class WriteVariableAction < VariableAction
attributes
  isRemove:Boolean
operations
end

--------------------------------------------------------------
-- package Computation actions. Apply function action
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

class ApplyFunctionAction < Action_
attributes
operations
end

class PrimitiveFunction < Action_
attributes
  pf_name:String
  language:String
  encoding:String
operations
end

class LiteralValueAction < Action_
attributes
operations
end

----------------------
-- association section
----------------------

-- Fig. 2-5

association Constraint_ModelElement between
  Constraint[*]
  ModelElement[1..*] role constrainedElement
end

composition Namespace_ModelElement between
  Namespace[0..1]
  ModelElement[*] role ownedElement
end

composition Classifier_Feature between
  Classifier[0..1] role owner
  Feature[*] ordered
end

composition BehavioralFeature_Parameter between
  BehavioralFeature[0..1]
  Parameter[*] ordered
end

association Operation_Method between
  Operation[1] role specification
  Method[*]
end

association Parameter_Classifier between
  Parameter[*]
  Classifier[1] role type
end

association StructuralFeature_Classifier between
  StructuralFeature[*]
  Classifier[1] role type
end


-- Fig. 2-6

association Flow_ModelElement1 between
  Flow[*] role sourceFlow
  ModelElement[*] role source
end

association Flow_ModelElement2 between
  Flow[*] role targetFlow
  ModelElement[*] role target
end

association Generalization_GeneralizableElement1 between
  Generalization[*] role generalization
  GeneralizableElement[1] role child
end

association Generalization_GeneralizableElement2 between
  Generalization[*] role specialization
  GeneralizableElement[1] role parent
end

association Generalization_Classifier between
  Generalization[*] role powertypeRange
  Classifier[0..1] role powertype
end

association AssociationEnd_Classifier1 between
  AssociationEnd[*]
  Classifier[1] role type
end

association AssociationEnd_Classifier2 between
  -- MM-ERR: role name not in Figure but in description
  AssociationEnd[*] role participant
  Classifier[*] role specification
end

composition Association_AssociationEnd between
  Association[1] role association_
  AssociationEnd[2..*] role connection ordered
end

composition AssociationEnd_Attribute between
  AssociationEnd[0..1]
  Attribute[*] role qualifier ordered
end


-- Fig. 2-7

association ModelElement_Dependency1 between
  ModelElement[1..*] role supplier
  Dependency[*] role supplierDependency
end

association ModelElement_Dependency2 between
  ModelElement[1..*] role client
  Dependency[*] role clientDependency
end

aggregation Binding_ModelElement between
  Binding[0..1]
  ModelElement[1..*] role argument ordered
end


-- Fig. 2-8

aggregation Node_Component between
  Node[*] role deploymentLocation
  Component[*] role resident
end

-- FIXME: association class
aggregation ElementResidence between
  Component[*] role implementationLocation
  ModelElement[*] role resident
end


-- Fig. 2-9

-- FIXME: association class
-- MM-ERR: name conflict between rolename templateParameter and
-- association class TemplateParameter
composition TemplateParameter between
  ModelElement[0..1] role mElement
  ModelElement[*] role templateParameter
end

association ModelElement_PresentationElement between
  ModelElement[*] role subject
  PresentationElement[*] role presentation
end

association ModelElement_Comment between
  ModelElement[*] role annotatedElement
  Comment[*]
end


-- Fig. 2-10

association ModelElement_Stereotype between
  ModelElement[*] role extendedElement
  Stereotype[0..1]
end

composition Stereotype_TaggedValue between
  Stereotype[0..1]
  TaggedValue[*] role requiredTag
end

-- MM-ERR: multiplicity at Stereotype originally 1, changed to 0..1
-- due to xor requirement

-- MM-ERR: rolename constrainedElement clashes with association end at
-- ModelElement, renamed to constrainedElement2

composition Stereotype_Constraint between
  Stereotype[0..1] role constrainedElement2
  Constraint[*] role stereotypeConstraint
end

composition ModelElement_TaggedValue between
  ModelElement[0..1]
  TaggedValue[*]
end


-- Fig. 2-14

association Signal_Reception between
  Signal[1]
  Reception[*]
end

association Signal_BehavioralFeature between
  Signal[*] role raisedSignal
  BehavioralFeature[*] role context_
end


-- Fig. 2-15

composition ActionSequence_Action between
  ActionSequence[0..1]
  Action[*] ordered
end

composition Action_Argument between
  Action[0..1]
  Argument[*] role actualArgument ordered
end

association CreateAction_Class between
  CreateAction[*]
  Classifier[1] role instantiation
end

association CallAction_Operation between
  CallAction[*]
  Operation[1]
end

association SendAction_Signal between
  SendAction[*]
  Signal[1]
end


-- Fig. 2-16

association Action_Stimulus between
  Action[1] role dispatchAction
  Stimulus[*]
end

association Attribute_AttributeLink between
  Attribute[1]
  AttributeLink[*]
end

association Stimulus_Link between
  Stimulus[*]
  Link[0..1] role communicationLink
end

composition Link_LinkEnd between
  Link[1]
  LinkEnd[2..*] role connection ordered
end

association Link_Association between
  Link[*]
  Association[1] role association_
end

association LinkEnd_AssociationEnd between
  LinkEnd[*]
  AssociationEnd[1]
end

association Classifier_Instance between
  Classifier[1..*]
  Instance[*]
end

composition Instance_AttributeLink between
  Instance[1]
  AttributeLink[*] role slot
end

association Instance_AttributeLink2 between
  Instance[1] role value
  AttributeLink[*]
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
aggregation Stimulus_Instance1 between
  Stimulus[*] role argumentStimulus
  Instance[*] role argument ordered
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
association Stimulus_Instance2 between
  Stimulus[*] role receiverStimulus
  Instance[1] role receiver
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
association Stimulus_Instance3 between
  Stimulus[*] role senderStimulus
  Instance[1] role sender
end

association Instance_LinkEnd between
  Instance[1] role instance
  LinkEnd[*]
end

association Instance_ComponentInstance between
  Instance[*] role resident
  ComponentInstance[0..1]
end

association ComponentInstance_NodeInstance between
  ComponentInstance[*] role resident
  NodeInstance[0..1]
end


-- Fig. 2-17 Collaborations

association Collaboration_Operation between
  Collaboration[*]
  Operation[0..1] role representedOperation
end

association Collaboration_Classifier between
  Collaboration[*]
  Classifier[0..1] role representedClassifier
end

-- Derived:
-- composition Collaboration_ClassifierRole between
--   Collaboration[1]
--   ClassifierRole[1..*] role ownedElement
-- end

composition Collaboration_Interaction between
  Collaboration[1] role context_
  Interaction[*]
end

aggregation Collaboration_ModelElement between
  Collaboration[*] role constrainingElement
  ModelElement[*]
end

-- Derived:
-- composition Collaboration_AssociationRole between
--   Collaboration[1]
--   AssociationRole[*] role ownedElement
-- end

association Association_AssociationRole between
  Association[0..1] role base
  AssociationRole[*]
end

association AssociationEnd_AssociationEndRole between
  AssociationEnd[0..1] role base
  AssociationEndRole[*]
end

-- Derived:
-- composition AssociationRole_AssociationEndRole between
--   AssociationRole[1]
--   AssociationEndRole[2..*] role connection ordered -- MM-ERR: ordered is missing
-- end

aggregation AssociationEndRole_Attribute between
  AssociationEndRole[*]
  Attribute[*] role availableQualifier
end

association AssociationRole_Message between
  AssociationRole[0..1] role communicationConnection
  Message[*]
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
association Message_Message1 between
  Message[*] role predecessor
  Message[*] role successor
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
association Message_Message2 between
  Message[0..1] role activator
  Message[*] role activateMessage
end

association Message_Action between
  Message[*]
  Action[1]
end

composition Interaction_Message between
  Interaction[1]
  Message[1..*]
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
association Message_ClassifierRole1 between
  Message[*] role senderMessage
  ClassifierRole[1] role sender
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
association Message_ClassifierRole2 between
  Message[*] role receiverMessage
  ClassifierRole[1] role receiver
end

-- Derived:
-- association AssociationEndRole_ClassifierRole between
--   AssociationEndRole[*]
--   ClassifierRole[1] role type
-- end

-- MM-ERR: default rolename `classifierRole' conflicts with
-- Classifierrole_Feature (see below)
aggregation ClassifierRole_ModelElement between
  ClassifierRole[*] role availableContentsOwner
  ModelElement[*] role availableContents
end

-- MM-ERR: default rolename `classifierRole' conflicts with
-- Classifierrole_Modelelement, because Feature is also a ModelElement
aggregation ClassifierRole_Feature between
  ClassifierRole[*] role availableFeatureOwner
  Feature[*] role availableFeature
end

association ClassifierRole_Classifier between
  ClassifierRole[*]
  Classifier[1..*] role base
end


-- Fig. 2-18 Use Cases

association UseCase_ExtensionPoint between
  UseCase[1]
  ExtensionPoint[*]
end

association Extend_ExtensionPoint between
  Extend[*]
  ExtensionPoint[1..*] ordered
end

association UseCase_Include1 between
  UseCase[1] role addition
  Include[*]
end

association UseCase_Include2 between
  UseCase[1] role base
  Include[*] role baseInclude
end

association UseCase_Extend1 between
  UseCase[1] role extension
  Extend[*] role extend
end

association UseCase_Extend2 between
  UseCase[1] role base
  Extend[*] role baseExtend
end


-- Fig. 2-21, 2-22 State Machines

aggregation ModelElement_StateMachine between
  ModelElement[0..1] role context_
  StateMachine[*] role behavior
end

composition StateMachine_State between
  StateMachine[0..1]
  State[1] role top
end

composition StateMachine_Transition between
  StateMachine[0..1]
  Transition[*]
end

composition Transition_Guard between
  Transition[1]
  Guard[0..1]
end

aggregation Transition_Event between
  Transition[*]
  Event[0..1] role trigger
end

composition Transition_Action between
  Transition[0..1]
  Action[0..1] role effect
end

association Transition_StateVertex1 between
  Transition[*] role outgoing
  StateVertex[1] role source
end

association Transition_StateVertex2 between
  Transition[*] role incoming
  StateVertex[1] role target
end

composition State_Transition between
  State[0..1]
  Transition[*] role internal
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
composition State_Action1 between
  State[0..1] role entryState
  Action[0..1] role entry
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
composition State_Action2 between
  State[0..1] role exitState
  Action[0..1] role exit
end

-- MM-ERR: default role name at State association end conflicts with
-- other unnamed association ends: Violation of WFR Classifier3. Added
-- a name.
composition State_Action3 between
  State[0..1] role activityState
  Action[0..1] role doActivity
end

association State_Event between
  State[*]
  Event[*] role deferrableEvent
end

composition CompositeState_StateVertex between
  CompositeState[0..1] role container
  StateVertex[*] role subvertex
end

association SubmachineState_StateMachine between
  SubmachineState[*]
  StateMachine[1] role submachine
end

composition Event_Parameter between
  Event[0..1]
  Parameter[*] ordered
end

association SignalEvent_Signal between
  SignalEvent[*] role occurrence
  Signal[1]
end

association CallEvent_Operation between
  CallEvent[*] role occurrence
  Operation[1]
end


-- Fig. 2-28, Activity Graphs

composition ActivityGraph_Partition between
  ActivityGraph[1]
  Partition[*]
end

association Partition_ModelElement between
  Partition[*] role part
  ModelElement[*] role contents
end

association State_ClassifierInState between
  State[1..*] role inState
  ClassifierInState[*]
end

association ObjectFlowState_Parameter between
  ObjectFlowState[*] role state
  Parameter[*]
end

association ObjectFlowState_Classifier between
  ObjectFlowState[*]
  Classifier[1] role type
end

association Classifier_ClassifierInState between
  Classifier[1] role type
  ClassifierInState[*]
end


-- Fig. 2-29, Model Management

-- FIXME: association class
aggregation Package_ModelElement between
  Package[*]
  ModelElement[*] role importedElement
end


--------------------------------------------------------------
-- package Identity_and_snapshot
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

association Snapshot_Identity between
  Snapshot[*]
  Identity[1] role identity
end

association Snapshot_Change1 between
  Snapshot[0..1] role predecessor
  Change[1] role postChange
end

association Snapshot_Change2 between
  Snapshot[0..1] role successor
  Change[1] role preChange
end

association Change_History between
  Change[*] role change
  History[1] role history
end


--------------------------------------------------------------
-- package execution dynamics fundamentals
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

association ExecutionSnapshot_Snapshot between
  ExecutionSnapshot [*] role accesor
  Snapshot [*] role referent
end

association Step_Change between
  Step [0..1] role cause
  Change [*] role effect
end

--------------------------------------------------------------
-- package instance
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

association DataValueIdentity_DataType between
  DataValueIdentity [*]
  DataType [1] role type
end

--------------------------------------------------------------
-- package object execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

-- Derived from Snapshot_Identity
association ObjectSnapshot_ObjectIdentity between
   ObjectSnapshot [*]
   ObjectIdentity [1] role objectId
end

association ObjectSnapshot_LinkEndValue between
   ObjectSnapshot [*]
   LinkEndValue [*] role linkEnd
end

composition ObjectSnapshot_AttributeValue between
   ObjectSnapshot [0..1]
   AttributeValue [*] role attributeValue
end

association ObjectSnapshot_Classifier between
   ObjectSnapshot [*] role oSnapshot
   Classifier [1..*] role classifier
end

association LinkEndValue_AssociationEnd between
   LinkEndValue [*]
   AssociationEnd [1] role associationEnd
end

association LinkEndValue_InstanceIdentity between
   LinkEndValue [*] role linkEndV
   InstanceIdentity [1] role value
end

association AttributeValue_InstanceIdentity between
   AttributeValue [*]
   InstanceIdentity [1] role value
end

association AttributeValue_pred_succ between
   AttributeValue [0..1] role predecessor
   AttributeValue [0..1] role successor
end

association AttributeValue_Attribute between
   AttributeValue [*]
   Attribute [1] role attribute_
end

--------------------------------------------------------------
-- package link execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

-- Derived from Snapshot_Identity
association LinkSnapshot_LinkIdentity between
  LinkSnapshot [*]
  LinkIdentity [1] role linkId
end

composition LinkIdentity_LinkEndValue between
  LinkIdentity [1] role link
  LinkEndValue [2..*] role linkEndValue
end

association LinkIdentity_Association between
  LinkIdentity [*]
  Association [1] role association_
end

association LinkEndValue_pred_succ between
  LinkEndValue [0..1] role predecessor
  LinkEndValue [0..1] role successor
end

composition LinkEndValue_AttributeValue between
  LinkEndValue [0..1]
  AttributeValue [*] role qualifierValue
end

--------------------------------------------------------------
-- package classifier extent
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

association ClassifierExtentIdentity_Classifier between
  ClassifierExtentIdentity [1] role extent
  Classifier [1] role classifier
end

-- Derived from Snapshot_Identity
association ClassifierExtentSnapshot_ClassifierExtentIdentity between
  ClassifierExtentSnapshot [*]
  ClassifierExtentIdentity [1] role extentId
end

association ClassifierExtentSnapshot_InstanceIdentity between
  ClassifierExtentSnapshot [1..*] role cExtentSnapshot
  Identity [1] role instanceIdentity -- name changed from `instance' by MR
end

composition ClassifierExtentSnapshot_AttributeValue between
  ClassifierExtentSnapshot [0..1]
  AttributeValue [*] role attributeValue
end

association ClassifierExtentSnapshot_LinkEndValue between
  ClassifierExtentSnapshot [*]
  LinkEndValue [*] role linkEnd
end

--------------------------------------------------------------
-- package association extent
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

association AssociationExtentIdentity_Association between
  AssociationExtentIdentity [1] role extent_a
  Association [1] role association_
end

-- Derived from Snapshot_Identity
association AssociationExtentSnapshot_AssociationExtentIdentity between
  AssociationExtentSnapshot [*]
  AssociationExtentIdentity [1] role extentId
end

association AssociationExtentSnapshot_LinkIdentity between
  AssociationExtentSnapshot [1]
  LinkIdentity [*] role link
end

--------------------------------------------------------------
-- package state machine execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

association StateMachineExecutionIdentity_ObjectIdentity between
  StateMachineExecutionIdentity [*]
  ObjectIdentity [1] role host
end

association StateMachineExecutionIdentity_StateMachine between
  StateMachineExecutionIdentity [*]
  StateMachine [1] role machine
end

association StateMachineExecutionIdentity_Occurrence between
  StateMachineExecutionIdentity [1]
  Occurrence [*] role occurrence
end

-- Derived from Snapshot_Identity
association StateMachineExecutionSnapshot_StateMachineExecutionIdentity between
  StateMachineExecutionSnapshot [*]
  StateMachineExecutionIdentity [1] role executionId
end

association StateMachineExecutionSnapshot_Occurrence between
  StateMachineExecutionSnapshot [*]
  Occurrence [0..1] role current
end

association StateMachineExecutionSnapshot_State between
  StateMachineExecutionSnapshot [*]
  State [1..*] role configuration
end

--------------------------------------------------------------
-- package occurrence
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

association Occurrence_Event between
  Occurrence [*]
  Event [1..*] role event
end

association Occurrence_InstanceIdentity between
  Occurrence [*]
  InstanceIdentity [*] role argument ordered
end

composition ObjectSnapshot_Occurrence between
  ObjectSnapshot [1]
  Occurrence [*] role occurrence ordered
end

association SignalOccurrence_ObjectSnapshot between
  SignalOccurrence [*]
  ObjectSnapshot [1] role signalInstance
end
--------------------------------------------------------------
-- package Action Foundation
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

--------------------------------------------------------------
-- Classes Multiplicity and MultiplicityRange
-- Modeled in order to be able to define DataFlow
-- after definition in Response to OMG RFP ad/98-11-01
--------------------------------------------------------------
-- associations
--------------------------------------------------------------
composition Multiplicity_MultiplicityRange between
  Multiplicity[1]
  MultiplicityRange[1..*] role range
end

association Action_ControlFlow between
   Action_ [1] role predecessor
   ControlFlow[*] role antecedant
end

association Action_ControlFlow2 between
   Action_ [1] role successor
   ControlFlow[*] role consequent
end

association Action_InputPin between
   Action_ [0..1] role action
   InputPin[*] role inputPin ordered
end

-- To be derived in subclasses
association Action_InputPin2 between
   Action_ [*]
   InputPin[*] role availableInput
end

association Action_OutputPin between
   Action_[0..1] role action
   OutputPin[*] role outputPin ordered
end

-- To be derived in subclasses
association Action_OutputPin2 between
   Action_ [*]
   OutputPin[*] role availableOutput
end

association DataFlow_InputPin between
   DataFlow[1] role flow
   InputPin[1] role destination
end

association DataFlow_OutputPin between
   DataFlow[*] role flow
   OutputPin[1] role source
end

association Pin_Classifier between
  Pin[*]
  Classifier [0..1] role type
end

association Procedure_InputPin between
   Procedure[0..1] role procedure1
   InputPin[*] role result ordered
end

association Procedure_OutputPin between
   Procedure[0..1] role procedure1
   OutputPin[*] role argument ordered
end

composition Procedure_Action between
   Procedure[0..1]
   Action_[1] role action
end

--------------------------------------------------------------
-- package action foundation execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------
association ActionExecutionIdentity_self between
  ActionExecutionIdentity [*]
  ActionExecutionIdentity [0..1] role _context
end

association ActionExecutionIdentity_Action between
  ActionExecutionIdentity [*]
  Action_ [1] role action
end

association ActionExecutionIdentity_ProcedureExecutionIdentity between
  ActionExecutionIdentity [1] role actionExecution
  ProcedureExecutionIdentity [0..1] role proceduralContext
end

-- Derived from Snapshot_Identity
association ActionExecutionSnapshot_ActionExecutionIdentity between
  ActionExecutionSnapshot [*]
  ActionExecutionIdentity [1] role executionID
end

composition ActionExecutionSnapshot_PinValue between
  ActionExecutionSnapshot [0..1] role actionExecution
  PinValue [*] role pinValue
end

association PinValue_Pin between
  PinValue [*]
  Pin [1] role pin
end

association PinValue_InstanceIdentity between
  PinValue [*]
  InstanceIdentity [*] role value ordered
end

composition ProcedureExecutionSnapshot_PinValue between
  ProcedureExecutionSnapshot [0..1] role procedureExecution
  PinValue [*] role pinValue
end

association ProcedureExecutionIdentity_InstanceIdentity between
  ProcedureExecutionIdentity [*]
  InstanceIdentity [0..1] role host
end

association ProcedureExecutionIdentity_Procedure between
  ProcedureExecutionIdentity [*]
  Procedure [1] role procedure1
end

-- Derived from Snapshot_Identity
association ProcedureExecutionSnapshot_ProcedureExecutionIdentity between
  ProcedureExecutionSnapshot [*]
  ProcedureExecutionIdentity [1] role executionID
end

--------------------------------------------------------------
-- package composite actions
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- classes
--------------------------------------------------------------

composition GroupAction_Action between
  GroupAction [0..1] role group
  Action_ [*] role subaction
end

composition GroupAction_Variable between
  GroupAction [0..1] role scope
  Variable [*] role variable
end

association Variable_Classifier between
  Variable [*]
  Classifier [1] role type
end

--------------------------------------------------------------
-- package composite action execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

-- Derived from Snapshot_Identity
association GroupExecutionSnapshot_GroupExecutionIdentity between
  GroupExecutionSnapshot [*]
  GroupExecutionIdentity [1] role groupExecutionID
end

association GroupExecutionIdentity_ActionExecutionIdentity between
  GroupExecutionIdentity [0..1]
  ActionExecutionIdentity [*] role subactionExecution
end

association GroupExecutionIdentity_VariableExecutionIdentity between
  GroupExecutionIdentity [1]
  VariableExecutionIdentity [*] role variableExecution
end

association VariableExecutionIdentity_Variable between
  VariableExecutionIdentity [*]
  Variable [1] role veiVariable -- name changed from `variable' by MR
end

-- Derived from Snapshot_Identity
association VariableExecutionSnapshot_VariableExecutionIdentity between
  VariableExecutionSnapshot [*]
  VariableExecutionIdentity [1] role executionID
end

association VariableExecutionSnapshot_InstanceIdentity between
  VariableExecutionSnapshot [*]
  InstanceIdentity [*] role value ordered
end

--------------------------------------------------------------
-- package Read and Write actions. Variable actions
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

association VariableAction_Variable between
  VariableAction [0..*]
  Variable [1] role variable
end

-- Derived from Action_OutputPin
association ReadVariableAction_OutputPin between
  ReadVariableAction [0..*]
  OutputPin [1] role result
end

-- Derived from Action_InputPin2
association WriteVariableAction_InputPin1 between
  WriteVariableAction [0..*] role WriteVariableAction1 -- added by MR
  InputPin [1] role value
end

-- Derived from Action_InputPin2
association WriteVariableAction_InputPin2 between
  WriteVariableAction [0..*] role WriteVariableAction2 -- added by MR
  InputPin [0..1] role insertAt
end

--------------------------------------------------------------
-- package Computation actions. Apply function action
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- associations
--------------------------------------------------------------

composition ApplyFunctionAction_InputPin between
  ApplyFunctionAction [0..1]
  InputPin [0..*] role argument ordered -- FIXME: DataValue?
end

composition ApplyFunctionAction_OutputPin between
  ApplyFunctionAction [0..1]
  OutputPin [0..*] role result ordered -- FIXME: DataValue?
end

association ApplyFunctionAction_PrimitiveFunction between
  ApplyFunctionAction [*]
  PrimitiveFunction [1] role function
end

association PrimitiveFunction_DataType1 between
  PrimitiveFunction [*] role inputTypeFunc -- added by MR
  DataType [0..*] role inputType
end

association PrimitiveFunction_DataType2 between
  PrimitiveFunction [*] role outputTypeFunc -- added by MR
  DataType [0..*] role outputType
end

association LiteralValueAction_OutputPin between
  LiteralValueAction [*]
  OutputPin [1] role result
end

association LiteralValueAction_DataValue between
  LiteralValueAction [*]
  DataValue [1] role value
end



---------------------
-- constraint section
---------------------

constraints

-- 2.5 Core

context Association

-- [1] The AssociationEnds must have a unique name within the
-- Association.

-- STATE: Ok

inv Association1:
  self.allConnections()->forAll( r1, r2 | r1.name = r2.name implies r1 = r2 )

-- [2] At most one AssociationEnd may be an aggregation or
-- composition.

-- STATE: E1: <>, I1.6

inv Association2:
  self.allConnections()->select(ae : AssociationEnd |
    ae.aggregation_ <> #none)->size <= 1

-- [3] If an Association has three or more AssociationEnds, then no
-- AssociationEnd may be an aggregation or composition.

-- STATE: E1: forall, I1.6

inv Association3:
  self.allConnections()->size >=3 implies
    self.allConnections()->forAll(ae : AssociationEnd |
      ae.aggregation_ = #none)

-- [4] The connected Classifiers of the AssociationEnds should be
-- included in the Namespace of the Association.

-- STATE: Ok

inv Association4:
  self.allConnections()->forAll (r |
    self.namespace.allContents()->includes(r.type))


context AssociationClass

-- [1] The names of the AssociationEnds and the StructuralFeatures do
-- not overlap.

-- STATE: E1: <

inv AssociationClass1:
  self.allConnections()->forAll( ar |
    self.allFeatures()->forAll( f |
      f.oclIsKindOf(StructuralFeature) implies ar.name <> f.name ))

-- [2] An AssociationClass cannot be defined between itself and
-- something else.

-- STATE: E1: <

inv AssociationClass2:
  self.allConnections()->forAll(ar | ar.type <> self)


context AssociationEnd

-- [1] The Classifier of an AssociationEnd cannot be an Interface or a
-- DataType if the association is navigable away from that end.

-- STATE: E1: <, oclIsKingOf, I1.7

inv AssociationEnd1:
  (self.type.oclIsKindOf(Interface) or
  self.type.oclIsKindOf(DataType)) implies
    self.association_.connection->select (ae | ae <> self)->forAll(ae |
      not ae.isNavigable)

-- [2] An Instance may not belong by composition to more than one
-- composite Instance.

-- STATE: E2.3: multiplicity.max

inv AssociationEnd2:
  true
--   self.aggregation = #composite implies self.multiplicity.max <= 1


context BehavioralFeature

-- [1] All Parameters should have a unique name.

-- STATE: Ok

inv BehavioralFeature1:
  self.parameter->forAll(p1, p2 | p1.name = p2.name implies p1 = p2)

-- [2] The type of the Parameters should be included in the Namespace of the Classifier.

-- STATE: Ok

inv BehavioralFeature2:
  self.parameter->forAll( p |
    self.owner.namespace.allContents()->includes (p.type) )


context Binding

-- [1] The argument ModelElement must conform to the parameter
-- ModelElement in a Binding. In an instantiation it must be of the
-- same kind.

-- No OCL

-- [2] A Binding has one client and one supplier.

-- STATE: Ok

inv Binding2:
  (self.client->size = 1) and (self.supplier->size = 1)

-- [3] A ModelElement may participate in at most one Binding as a
-- client.

-- STATE: E1: []

inv Binding3:
  Binding.allInstances->forAll(b1, b2 |
   (b1 <> b2) implies (b1.client <> b2.client))


context Class

-- [1] If a Class is concrete, all the Operations of the Class should
-- have a realizing Method in the full descriptor.

-- STATE: Ok, I1.2

inv Class1:
  not self.isAbstract implies self.allOperations()->forAll(op |
    self.allMethods()->exists(m | m.specification = op))

-- [2] A Class can only contain Classes, Associations,
-- Generalizations, UseCases, Constraints, Dependencies,
-- Collaborations, DataTypes, and Interfaces as a Namespace.

-- STATE: E1: ->, missing ), I1.5: UseCase, Collaboration

inv Class2:
  self.allContents()->forAll(c |
    c.oclIsKindOf(Class ) or 
    c.oclIsKindOf(Association ) or 
    c.oclIsKindOf(Generalization) or 
    c.oclIsKindOf(UseCase ) or 
    c.oclIsKindOf(Constraint ) or 
    c.oclIsKindOf(Dependency ) or 
    c.oclIsKindOf(Collaboration ) or 
    c.oclIsKindOf(DataType ) or 
    c.oclIsKindOf(Interface ))


context Classifier

-- [1] No BehavioralFeature of the same kind may match the same
-- signature in a Classifier.

-- STATE: I1.5: Reception, E3.4: matchesSignature(g)

inv Classifier1:
  self.feature->forAll(f, g |
  (
    (
      (f.oclIsKindOf(Operation) and g.oclIsKindOf(Operation)) or
      (f.oclIsKindOf(Method ) and g.oclIsKindOf(Method )) or
      (f.oclIsKindOf(Reception) and g.oclIsKindOf(Reception))
    ) and
    f.oclAsType(BehavioralFeature).matchesSignature(g.oclAsType(BehavioralFeature))
  ) implies f = g)

-- [2] No Attributes may have the same name within a Classifier.

-- STATE: Ok

inv Classifier2:
  self.feature->select ( a | a.oclIsKindOf (Attribute) )->forAll ( p, q |
    p.name = q.name implies p = q )

-- [3] No opposite AssociationEnds may have the same name within a
-- Classifier.

-- STATE: E2.3: oppositeEnds

inv Classifier3:
  self.oppositeAssociationEnds()->forAll ( p, q | p.name = q.name implies p = q )

-- [4] The name of an Attribute may not be the same as the name of an
-- opposite AssociationEnd or a ModelElement contained in the
-- Classifier.

-- STATE: E3.4: union, I1.8 changed order of union

inv Classifier4:
  self.feature->select( a | a.oclIsKindOf (Attribute) )->forAll ( a |
    not self.allContents()->union(self.allOppositeAssociationEnds())->collect( q |
      q.name)->includes(a.name))

-- [5] The name of an opposite AssociationEnd may not be the same as
-- the name of an Attribute or a ModelElement contained in the
-- Classifier.

-- STATE: E3.4: union, I1.8: changed order of union

inv Classifier5:
  self.oppositeAssociationEnds()->forAll( o |
    not self.allContents()->union(self.allAttributes())->collect ( q |
      q.name)->includes (o.name))

-- [6] For each Operation in an specification realized by the
-- Classifier, the Classifier must have a matching Operation.

-- STATE: I1.1: specification->forAll, E2.3: hasMatchingSignature

inv Classifier6:
  self.specification()->forAll(c |
    c.allOperations()->forAll(interOp |
      self.allOperations()->exists( op | op.matchesSignature(interOp))))

-- [7] All of the generalizations in the range of a powertype have the
-- same discriminator.

-- STATE: Ok

inv Classifier7:
  self.powertypeRange->forAll(g1, g2 | g1.discriminator = g2.discriminator)

-- [8] Discriminator names must be distinct from attribute names and
-- opposite AssociationEnd names.

-- STATE: Ok, I1.1

inv Classifier8:
  self.allDiscriminators()->intersection(
    self.allAttributes()->collect(a | a.name)->union
      (self.allOppositeAssociationEnds()->collect(ae |
        ae.name))->asSet)->isEmpty


context Component

-- [1] A Component may only contain other Components.

-- STATE: E1: -

inv Component1:
  self.allContents()->forAll( c | c.oclIsKindOf(Component))

-- [2] A Component may only implement DataTypes, Interfaces, Classes,
-- Associations, Dependencies, Constraints, Signals, DataValues and
-- Objects.

-- STATE: E1: -, I1.5

inv Component2:
  self.allResidentElements()->forAll( re |
    re.oclIsKindOf(DataType) or
    re.oclIsKindOf(Interface) or
    re.oclIsKindOf(Class) or
    re.oclIsKindOf(Association) or
    re.oclIsKindOf(Dependency) or
    re.oclIsKindOf(Constraint) or
    re.oclIsKindOf(Signal) or
    re.oclIsKindOf(DataValue) or
    re.oclIsKindOf(Object)
    )


context Constraint

-- [1] A Constraint cannot be applied to itself.

-- STATE: Ok

inv Constraint1:
  not self.constrainedElement->includes(self)


context DataType

-- [1] A DataType can only contain Operations, which all must be queries.

-- STATE: Ok

inv DataType1:
  self.allFeatures()->forAll(f |
    f.oclIsKindOf(Operation) and f.oclAsType(Operation).isQuery)

-- [2] A DataType cannot contain any other ModelElements.

-- STATE: Ok

inv DataType2:
  self.allContents()->isEmpty


context GeneralizableElement

-- [1] A root cannot have any Generalizations.

-- STATE: Ok

inv GeneralizableElement1:
  self.isRoot implies self.generalization->isEmpty

-- [2] No GeneralizableElement can have a parent Generalization to an
-- element which is a leaf.

-- STATE: Ok

inv GeneralizableElement2:
  self.parent()->forAll(s | not s.isLeaf)

-- [3] Circular inheritance is not allowed.

-- STATE: Ok

inv GeneralizableElement3:
  not self.allParents()->includes(self)

-- [4] The parent must be included in the Namespace of the
-- GeneralizableElement.

-- STATE: Ok

inv GeneralizableElement4:
  self.generalization->forAll(g |
    self.namespace.allContents()->includes(g.parent) )


-- E0
-- context ImplementationClass (stereotype of Class)


context Interface

-- [1] An Interface can only contain Operations.

-- STATE: Ok, I1.5: Reception

inv Interface1:
  self.allFeatures()->forAll(f |
    f.oclIsKindOf(Operation) )
--    f.oclIsKindOf(Operation) or f.oclIsKindOf(Reception))

-- [2] An Interface cannot contain any ModelElements.

-- STATE: Ok

inv Interface2:
  self.allContents()->isEmpty

-- [3] All Features defined in an Interface are public.

-- STATE: Ok

inv Interface3:
  self.allFeatures()->forAll ( f | f.visibility = #public )


context Method

-- [1] If the realized Operation is a query, then so is the Method.

-- STATE: E4.2: ->isQuery

inv Method1:
  self.specification.isQuery implies self.isQuery 

-- [2] The signature of the Method should be the same as the signature
-- of the realized Operation.

-- STATE: Ok

inv Method2:
  self.hasSameSignature(self.specification)

-- [3] The visibility of the Method should be the same as for the
-- realized Operation.

-- STATE: Ok

inv Method3:
  self.visibility = self.specification.visibility

-- [4] The realized Operation must be a feature (possibly inherited)
-- of the same Classifier as the Method.

-- STATE: Ok

inv Method4:
  self.owner.allOperations()->includes(self.specification)

-- [5] If the realized Operation has been overridden one or more times
-- in the ancestors of the owner of the Method, then the Method must
-- realize the latest overriding (that is, all other Operations with
-- the same signature must be owned by ancestors of the owner of the
-- real-ized Operation).

-- STATE: E1: missing )

inv Method5:
  self.specification.owner.allOperations()->includesAll(
    (self.owner.allOperations()->select(op |
      self.hasSameSignature(op))))


context Namespace

-- [1] If a contained element, which is not an Association or
-- Generalization has a name, then the name must be unique in the
-- Namespace.

-- STATE: E1: <

inv Namespace1:
  self.allContents()->forAll(me1, me2 : ModelElement |
    ( not me1.oclIsKindOf (Association) and
      not me2.oclIsKindOf (Association) and
      me1.name <> '' and
      me2.name <> '' and
      me1.name = me2.name
     ) implies me1 = me2 )

-- [2] All Associations must have a unique combination of name and
-- associated Classifiers in the Namespace.

-- STATE: I1.6, E3.2, I1.1

inv Namespace2:
  self.allContents()->select(m : ModelElement |
    m.oclIsKindOf(Association))->collect(m : ModelElement |
    m.oclAsType(Association))->forAll(a1, a2 |
      a1.name = a2.name and
      a1.connection->collect(ae : AssociationEnd | ae.type) =
      a2.connection->collect(ae : AssociationEnd | ae.type)
      implies a1 = a2)

context StructuralFeature

-- [1] The connected type should be included in the owner's Namespace.

-- STATE: Ok

inv StructuralFeature1:
  self.owner.namespace.allContents()->includes(self.type)

-- [2] The type of a StructuralFeature must be a Class, DataType or Interface.

-- STATE: Ok

inv StructuralFeature2:
  self.type.oclIsKindOf(Class) or
  self.type.oclIsKindOf(DataType) or
  self.type.oclIsKindOf(Interface)


-- E0
-- context Trace

--  E0
-- context Type

-- 2.6 Extension Mechanisms

context Stereotype

-- [1] Stereotype names must not clash with any baseClass names.

-- STATE: E1: oclAllInstances, E4.3: self -> st

inv Stereotype1:
  Stereotype.allInstances->forAll(st | st.baseClass <> st.name)

-- [2] Stereotype names must not clash with the names of any inherited
-- Stereotype.

-- STATE: E2.3: allSupertypes, E3.2: st

inv Stereotype2:
  self.allParents()->forAll(g : GeneralizableElement |
    g.oclIsKindOf(Stereotype) implies g.name <> self.name)

-- [4] The baseClass name must be provided; icon is optional and is
-- specified in an implementation specific way.

-- STATE: Ok

inv Stereotype4:
  self.baseClass <> ''


context ModelElement

-- [2] A model element must have at most one tagged value with a given
-- tag name.

-- STATE: Ok

inv ModelElement2:
  self.taggedValue->forAll(t1, t2 : TaggedValue |
    t1.tag = t2.tag implies t1 = t2)

-- [3] (Required tags because of stereotypes) If T in
-- modelElement.stereotype.require Tag.such that T.value =
-- unspecified, then the modelElement must have a tagged value with
-- name = T.name.

-- STATE: E2.3, E4.4: no Undefined literal in OCL, E4.5

inv ModelElement3:
  self.stereotype.isDefined() implies
   self.stereotype.requiredTag->forAll(tag |
    tag.value.isUndefined() implies self.taggedValue->exists(t |
      t.tag = tag.tag))

-- 2.7 Data Types

-- no WFRs

-- 2.9 Common Behavior

context AttributeLink

-- [1] The type of the Instance must match the type of the Attribute.

-- STATE: E3.2: allParents returns GeneralizableElement, I1.1, I1.3

inv AttributeLink1:
  self.value.classifier->union (
    self.value.classifier->collect(c | c.allParents())->flatten->collect(ge |
      ge.oclAsType(Classifier)))->includes (
        self.attribute.type)

context CallAction

-- [1] The number of arguments be the same as the number of the
-- Operation.

-- STATE: Ok

inv CallAction1:
  self.actualArgument->size = self.operation.parameter->size


context ComponentInstance

-- [1] A ComponentInstance originates from exactly one Component.

-- STATE: E4.2: oclIsKindOf

inv ComponentInstance1:
  self.classifier->size = 1
  and
  self.classifier->forAll(c | c.oclIsKindOf (Component))


context CreateAction

-- [1] A CreateAction does not have a target expression.

-- STATE: E4.2: -> E4.4: isEmpty

inv CreateAction1:
  self.target.isUndefined()


context DestroyAction

-- [1] A DestroyAction should not have arguments

-- STATE: Ok

inv DestroyAction1:
  self.actualArgument->size = 0


context DataValue

-- [1] A DataValue originates from exactly one Classifier, which is a
-- DataType.

-- STATE: E4.2: oclIsKindOf

inv DataValue1:
  (self.classifier->size = 1)
  and
  self.classifier->forAll(c | c.oclIsKindOf(DataType))

-- [2] A DataValue has no AttributeLinks.

-- STATE: Ok

inv DataValue2:
  self.slot->isEmpty


context Instance

-- [1] The AttributeLinks match the declarations in the Classifiers.

-- STATE: Ok

inv Instance1:
  self.slot->forAll ( al |
    self.classifier->exists ( c |
      c.allAttributes()->includes ( al.attribute ) ) )

-- [2] The Links matches the declarations in the Classifiers.

-- STATE: Ok

inv Instance2:
  self.allLinks()->forAll ( l |
    self.classifier->exists ( c |
      c.allAssociations()->includes ( l.association_ ) ) )

-- [3a] If two Operations have the same signature they must be the
-- same.

-- STATE: Ok

inv Instance3a:
  self.classifier->forAll ( c1, c2 |
    c1.allOperations()->forAll ( op1 |
      c2.allOperations()->forAll ( op2 |
        op1.hasSameSignature (op2) implies op1 = op2 ) ) )


-- [3b] There are no name conflicts between the AttributeLinks and
-- opposite LinkEnds.

-- STATE: Ok

inv Instance3b:
  self.slot->forAll( al |
    not self.allOppositeLinkEnds()->exists( le | le.name = al.name ) )
  and
    self.allOppositeLinkEnds()->forAll( le |
      not self.slot->exists( al | le.name = al.name ) )


-- [4] For each Association in which an Instance is involved, the
-- number of opposite LinkEnds must match the multiplicity of the
-- AssociationEnd.

-- STATE: FIXME: need multiplicity data type or class

inv Instance4:
  true
--   self.classifier->collect(c | c.allOppositeAssociationEnds())->flatten->forAll ( ae |
--     ae.multiplicity.multiplicityRange->exists ( mr |
--       self.selectedLinkEnds (ae)->size >= mr.lower and
--       (mr.upper =  unlimited  or
--         (mr.upper <>  unlimited  and
--           self.selectedLinkEnds (ae)->size <=
--           mr.upper.oclAsType (Integer) ) ) ) )

-- [5] The number of associated AttributeLinks must match the
-- multiplicity of the Attribute.

-- STATE: FIXME: need multiplicity data type or class

inv Instance5:
  true
--   self.classifier.allAttributes->forAll ( a |
--     a.multiplicity.multiplicityRange->exists ( mr |
--       self.selectedAttributeLinks (a)->size >= mr.lower and
--       (mr.upper =  unlimited  or
--         (mr.upper <>  unlimited  and
--           self.selectedLinkEnds (a)->size <=
--           mr.upper.oclAsType (Integer) ) ) ) )


context Link

-- [1] The set of LinkEnds must match the set of AssociationEnds of
-- the Association.

-- STATE: Ok

inv Link1:
  Sequence {1..self.connection->size}->forAll ( i |
    self.connection->at (i).associationEnd =
    self.association_.connection->at (i) )

-- [2] There are not two Links of the same Association which connects
-- the same set of Instances in the same way.

-- STATE: Ok

inv Link2:
  self.association_.link->forAll ( l |
    Sequence {1..self.connection->size}->forAll ( i |
      self.connection->at (i).instance =
      l.connection->at (i).instance )
        implies self = l )


context LinkEnd

-- [1] The type of the Instance must match the type of the
-- AssociationEnd.

-- STATE: E3.2: allParents returns Set(GeneralizableElement), I1.1, I1.3, I1.8

inv LinkEnd1:
  self.instance.classifier->collect(c | c.allParents())->flatten->asSet->union(
  self.instance.classifier)->includes (
      self.associationEnd.type)


context LinkObject

-- [1] One of the Classifiers must be the same as the Association.

-- STATE: I1.8: would require includes(:OclAny) to type check

inv LinkObject1:
   self.classifier->includes(self.association_.oclAsType(AssociationClass))

-- [2] The Association must be a kind of AssociationClass.

-- STATE: Ok

inv LinkObject2:
  self.association_.oclIsKindOf(AssociationClass)


context NodeInstance

-- [1] A NodeInstance must have only one Classifier as its origin, and
-- it must be a Node.

-- STATE: Ok

inv NodeInstance1:
  self.classifier->forAll ( c | c.oclIsKindOf(Node))
  and
  self.classifier->size = 1

-- [2] Each ComponentInstance that resides on a NodeInstance must be
-- an instance of a Component that resides on the corresponding Node.

-- STATE: E4.1

-- inv NodeInstance2:
--   self.resident->forAll(n |
--     self.classifier.resident->includes(n.classifier))


context Object

-- [1] Each of the Classifiers must be a kind of Class.

-- STATE: Ok

inv Object1:
  self.classifier->forAll ( c | c.oclIsKindOf(Class))


context Reception

-- [1] A Reception can not be a query.

-- STATE: Ok

inv Reception1:
  not self.isQuery


context SendAction

-- [1] The number of arguments is the same as the number of parameters
-- of the Signal.

-- STATE: Ok

inv SendAction1:
  self.actualArgument->size = self.signal.allAttributes()->size

-- [2] A Signal is always asynchronous.

-- STATE: Ok

inv SendAction2:
  self.isAsynchronous


context Stimulus

-- [1] The number of arguments must match the number of Arguments of the Action.

-- STATE: Ok

inv Stimulus1:
  self.dispatchAction.actualArgument->size = self.argument->size

-- [2] The Action must be a SendAction, a CallAction, a CreateAction,
-- or a DestroyAction.

-- STATE: Ok

inv Stimulus2:
  self.dispatchAction.oclIsKindOf (SendAction) or
  self.dispatchAction.oclIsKindOf (CallAction) or
  self.dispatchAction.oclIsKindOf (CreateAction) or
  self.dispatchAction.oclIsKindOf (DestroyAction)

context TerminateAction

-- [1] A TerminateAction has no arguments.

-- STATE: E1

inv TerminateAction1:
  self.actualArgument->size = 0

-- [2] A TerminateAction has no target expression.

-- STATE: E4.4, E4.2: ->

inv TerminateAction2:
  self.target.isUndefined()

----------------------
-- 2-10 Collaborations
----------------------

context AssociationEndRole

-- [1] The type of the ClassifierRole must conform to the type of the
-- base AssociationEnd.

-- STATE: E4.2: self.type.base returns set, E3.2: see inv AssociationEndRole2

inv AssociationEndRole1:
--   self.type.base = self.base.type 
--   or 
     self.type.oclAsType(ClassifierRole).base.allParents()->includes (self.base.type)

-- [2] The type must be a kind of ClassifierRole.

-- STATE: E2.2: roleType

inv AssociationEndRole2:
  self.type.oclIsKindOf (ClassifierRole)

-- [3] The qualifiers used in the AssociationEndRole must be a subset
-- of those in the base AssociationEnd.

-- STATE: E3.4: Sequence->asSet

inv AssociationEndRole3:
  self.base.qualifier->asSet->includesAll (self.availableQualifier)

-- [4] In a collaboration an association may only be used for
-- traversal if it is allowed by the base association.

-- STATE: Ok

inv AssociationEndRole4:
  self.isNavigable implies self.base.isNavigable


context AssociationRole

-- [1] The AssociationEndRoles must conform to the AssociationEnds of
-- the base Association.

-- STATE: E3.2: see inv AssociationRole2

inv AssociationRole1:
  Sequence{ 1..(self.connection->size) }->forAll (index | 
    self.connection->at(index).oclAsType(AssociationEndRole).base = 
    self.base.connection->at(index))

-- [2] The endpoints must be a kind of AssociationEndRoles.

-- STATE: Ok

inv AssociationRole2:
  self.connection->forAll( r | r.oclIsKindOf (AssociationEndRole) )

context ClassifierRole

-- [1] The AssociationRoles connected to the ClassifierRole must match
-- a subset of the Associations connected to the base Classifiers.

-- STATE: E4.1

inv ClassifierRole1:
  true
--   self.allAssociations()->forAll( ar |
--     self.base.allAssociations->exists ( a | ar.base = a ) )

-- [2] The Features and contents of the ClassifierRole must be subsets
-- of those of the base Classifiers.

-- STATE: E3.4, E4.1, I1.1, I1.3

inv ClassifierRole2:
  self.base->collect(c | c.allFeatures())->flatten->asSet->
    includesAll (self.allAvailableFeatures())
  and
  self.base->collect(c | c.allContents())->flatten->asSet->
    includesAll (self.allAvailableContents())

-- [3] A ClassifierRole does not have any Features of its own.

-- STATE: Ok

inv ClassifierRole3:
  self.allFeatures()->isEmpty


context Collaboration

-- [1] All Classifiers and Associations of the ClassifierRoles and
-- AssociationRoles in the Collaboration must be included in the
-- namespace owning the Collaboration.

-- STATE: E3.4: ->includesAll

inv Collaboration1:
  self.allContents()->forAll ( e |
    (e.oclIsKindOf (ClassifierRole) implies
       self.namespace.allContents()->includesAll (
         e.oclAsType(ClassifierRole).base) )
    and
    (e.oclIsKindOf (AssociationRole) implies
       self.namespace.allContents()->includes (
         e.oclAsType(AssociationRole).base) ))

-- [2] All the constraining ModelElements must be included in the
-- namespace owning the Collaboration.

-- STATE: Ok

inv Collaboration2:
  self.constrainingElement->forAll ( ce |
    self.namespace.allContents()->includes (ce) )

-- [3] If a ClassifierRole or an AssociationRole does not have a name
-- then it should be the only one with a particular base.

-- STATE: Ok

inv Collaboration3:
  self.allContents()->forAll ( p |
    (p.oclIsKindOf (ClassifierRole) implies
      p.name = '' implies
        self.allContents()->forAll ( q |
          q.oclIsKindOf(ClassifierRole) implies
            (p.oclAsType(ClassifierRole).base =
              q.oclAsType(ClassifierRole).base implies
                p = q) ) )
    and
    (p.oclIsKindOf (AssociationRole) implies
      p.name = '' implies
        self.allContents()->forAll ( q |
          q.oclIsKindOf(AssociationRole) implies
            (p.oclAsType(AssociationRole).base =
               q.oclAsType(AssociationRole).base implies
                 p = q) ) ) )

-- [4] A Collaboration may only contain ClassifierRoles and
-- AssociationRoles, and the Generalizations and the Constraints
-- between them.

-- STATE: Ok

inv Collaboration4:
  self.allContents()->forAll ( p |
    p.oclIsKindOf (ClassifierRole) or
    p.oclIsKindOf (AssociationRole) or
    p.oclIsKindOf (Generalization) or
    p.oclIsKindOf (Constraint) )

-- [5] A role with the same name as one of the roles in a parent of
-- the Collaboration must be a child (a specialization) of that role.

-- STATE: E4.1

inv Collaboration5:
  true
--   self.contents()->forAll ( c |
--     self.parent().allContents()->forAll ( p |
--       c.name = p.name implies c.allParents()->include (p) ))


context Interaction

-- [1] All Signals being sent must be included in the namespace owning
-- the Collaboration in which the Interaction is defined.

-- STATE: E1: ->oclAsType

inv Interaction1:
  self.message->forAll ( m |
    m.action.oclIsKindOf(SendAction) implies
      self.context_.namespace.allContents()->includes (
        m.action.oclAsType(SendAction).signal) )


context Message

-- [1] The sender and the receiver must participate in the
-- Collaboration which defines the context of the Interaction.

-- STATE: Ok

inv Message1:
  self.interaction.context_.ownedElement->includes (self.sender)
  and
  self.interaction.context_.ownedElement->includes (self.receiver)

-- [2] The predecessors and the activator must be contained in the
-- same Interaction.

-- STATE: E4.2, E4.5: activator is optional

inv Message2:
  self.predecessor->forAll ( p | p.interaction = self.interaction )
  and
  self.activator.isDefined() implies
    self.activator.interaction = self.interaction

-- [3] The predecessors must have the same activator as the Message.

-- STATE: Ok

inv Message3:
  self.allPredecessors()->forAll ( p | p.activator = self.activator )

-- [4] A Message cannot be the predecessor of itself.

-- STATE: Ok

inv Message4:
  not self.allPredecessors()->includes (self)

-- [5] The communicationLink of the Message must be an AssociationRole
-- in the context of the Message's Interaction

-- STATE: Ok

inv Message5:
  self.interaction.context_.ownedElement->includes (
    self.communicationConnection)

-- [6] The sender and the receiver roles must be connected by the
-- AssociationRole which acts as the communication connection.

-- STATE: E2.2: roleConnection, roleType

inv Message6:
  self.communicationConnection->size > 0 implies 
    self.communicationConnection.connection->exists (ar | 
      ar.type = self.sender) 
    and 
    self.communicationConnection.connection->exists (ar | 
      ar.type = self.receiver)

-----------------
-- 2-11 Use Cases
-----------------

context Actor

-- [1] Actors can only have Associations to UseCases, Subsystems, and
-- Classes and these Associations are binary.

-- STATE: Ok

inv Actor1:
  self.associations()->forAll(a |
    a.connection->size = 2 and
    a.allConnections()->exists(r | r.type.oclIsKindOf(Actor)) and
    a.allConnections()->exists(r |
      r.type.oclIsKindOf(UseCase) or
      r.type.oclIsKindOf(Subsystem) or
      r.type.oclIsKindOf(Class)))

-- [2] Actors cannot contain any Classifiers.

-- STATE: Ok

inv Actor2:
  self.contents()->isEmpty

context Extend

-- [1] The referenced ExtensionPoints must be included in set of
-- ExtensionPoint in the target UseCase.

-- STATE: E4.5: location

inv Extend1:
  self.base.allExtensionPoints() -> includesAll (self.extensionPoint->asSet)

context ExtensionPoint

-- [1] The name must not be the empty string

-- STATE: E1, E2.4

inv ExtensionPoint1:
  self.name <> ''


context UseCase

-- [1] UseCases can only have binary Associations.

-- STATE: Ok

inv UseCase1:
  self.associations()->forAll(a | a.connection->size = 2)

-- [2] UseCases can not have Associations to UseCases specifying the
-- same entity.

-- STATE: E3.2: type returns Classifier

inv UseCase2:
  self.associations()->forAll(a |
    a.allConnections()->forAll(s, o|
      (s.type.oclAsType(UseCase).specificationPath()->isEmpty and
      o.type.oclAsType(UseCase).specificationPath()->isEmpty )
    or
      (not s.type.oclAsType(UseCase).specificationPath()->includesAll(
        o.type.oclAsType(UseCase).specificationPath()) and
      not o.type.oclAsType(UseCase).specificationPath()->includesAll(
        s.type.oclAsType(UseCase).specificationPath()))
    ))

-- [3] A UseCase cannot contain any Classifiers.

-- STATE: E4.5: contents() returns a set of ModelElements!

inv UseCase3:
  self.contents()->forAll(me | not me.oclIsKindOf(Classifier))

-- [4] The names of the ExtensionPoints must be unique within the
-- UseCase.

-- STATE: Ok

inv UseCase4:
  self.allExtensionPoints()-> forAll (x, y | x.name = y.name implies x = y )

context UseCaseInstance

-- [1] The Classifier of a UseCaseInstance must be a UseCase.

-- STATE: Ok

inv UseCaseInstance1:
  self.classifier->forAll ( c | c.oclIsKindOf (UseCase) )


----------------------
-- 2-12 State Machines
----------------------

context CompositeState

-- [1] A composite state can have at most one initial vertex

-- STATE: E3.2

inv CompositeState1:
  self.subvertex->select (v | v.oclIsKindOf(PseudoState))->
    select(s : StateVertex | s.oclAsType(PseudoState).kind = #initial)->size <= 1

-- [2] A composite state can have at most one deep history vertex

-- STATE: E3.2

inv CompositeState2:
  self.subvertex->select (v | v.oclIsKindOf(PseudoState))->
    select(s : StateVertex | s.oclAsType(PseudoState).kind = #deepHistory)->size <= 1

-- [3] A composite state can have at most one shallow history vertex

-- STATE: E3.2

inv CompositeState3:
  self.subvertex->select(v | v.oclIsKindOf(PseudoState))->
    select(s : StateVertex | s.oclAsType(PseudoState).kind = #shallowHistory)->size <= 1

-- [4] There have to be at least two composite substates in a concurrent composite state

-- STATE: Ok

inv CompositeState4:
  (self.isConcurrent) implies
    (self.subvertex->select
       (v | v.oclIsKindOf(CompositeState))->size >= 2)

-- [5] A concurrent state can only have composite states as substates

-- STATE: E1: missing )

inv CompositeState5:
  (self.isConcurrent) implies
     self.subvertex->forAll(s | s.oclIsKindOf(CompositeState))

-- [6] The substates of a composite state are part of only that composite state

-- STATE: E4.4

inv CompositeState6:
  self.subvertex->forAll(s | s.container = self)


context FinalState

-- [1] A final state cannot have any outgoing transitions

-- STATE: Ok

inv FinalState1:
  self.outgoing->size = 0


context Guard

-- [1] A guard should not have side effects

-- STATE: E4.1: pre/post in invariant?!

inv Guard1:
  true
--   self.transition->stateMachine->notEmpty implies
--     post: (self.transition.stateMachine->context =
--     self.transition.stateMachine->context@pre)


context PseudoState

-- [1] An initial vertex can have at most one outgoing transition and
-- no incoming transitions

-- STATE: Ok

inv PseudoState1:
  (self.kind = #initial) implies
    ((self.outgoing->size <= 1) and (self.incoming->isEmpty))

-- [2] History vertices can have at most one outgoing transition

-- STATE: Ok

inv PseudoState2:
 ((self.kind = #deepHistory) or (self.kind = #shallowHistory)) implies
   (self.outgoing->size <= 1)

-- [3] A join vertex must have at least two incoming transitions and
-- exactly one outgoing transition.

-- STATE: Ok

inv PseudoState3:
  (self.kind = #join) implies
    ((self.outgoing->size = 1) and (self.incoming->size >= 2))

-- [4] A fork vertex must have at least two outgoing transitions and
-- exactly one incoming transition.

-- STATE: Ok

inv PseudoState4:
  (self.kind = #fork) implies
    ((self.incoming->size = 1) and (self.outgoing->size >= 2))

-- [5] A junction vertex must have at least one incoming and one
-- outgoing transition.

-- STATE: Ok

inv PseudoState5:
  (self.kind = #junction) implies
    ((self.incoming->size >= 1) and (self.outgoing->size >= 1))

-- [6] A choice vertex must have at least one incoming and one
-- outgoing transition.

-- STATE: Ok

inv PseudoState6:
  (self.kind = #choice) implies
    ((self.incoming->size >= 1) and (self.outgoing->size >= 1))


context StateMachine

-- [1] A StateMachine is aggregated within either a classifier or a
-- behavioral feature.

-- STATE: Ok

inv StateMachine1:
  self.context_.oclIsKindOf(BehavioralFeature) or
  self.context_.oclIsKindOf(Classifier)

-- [2] A top state is always a composite.

-- STATE: Ok

inv StateMachine2:
  self.top.oclIsTypeOf(CompositeState)

-- [3] A top state cannot have any containing states

-- STATE: Ok

inv StateMachine3:
  self.top.container->isEmpty()

-- [4] The top state cannot be the source of a transition.

-- STATE: Ok

inv StateMachine4:
  (self.top.outgoing->isEmpty())

-- [5] If a StateMachine describes a behavioral feature, it contains
-- no triggers of type CallEvent, apart from the trigger on the
-- initial transition (see OCL for Transition [8]).

-- STATE: E1: transitions, I1.1

inv StateMachine5:
  self.context_.oclIsKindOf(BehavioralFeature) implies
  self.transition->reject(t |
    t.source.oclIsKindOf(PseudoState) and
      t.source.oclAsType(PseudoState).kind= #initial
    )->collect(t | t.trigger)->isEmpty()


context SynchState

-- [1] The value of the bound attribute must be a positive integer, or unlimited.

-- STATE: Ok

inv SynchState1:
  (self.bound > 0) -- FIXME: needs UnlimitedInteger: or (self.bound = unlimited)


context SubmachineState

-- [1] Only stub states allowed as substates of a submachine state.

-- STATE: Ok

inv SubmachineState1:
  self.subvertex->forAll (s | s.oclIsTypeOf(StubState))

-- [2] Submachine states are never concurrent.

-- STATE: Ok

inv SubmachineState2:
  self.isConcurrent = false


context Transition

-- [1] A fork segment should not have guards or triggers.

-- STATE: Ok

inv Transition1:
  self.source.oclIsKindOf(PseudoState) implies 
    ((self.source.oclAsType(PseudoState).kind = #fork) implies 
       ((self.guard->isEmpty) and (self.trigger->isEmpty)))

-- [2] A join segment should not have guards or triggers.

-- STATE: Ok

inv Transition2:
  self.target.oclIsKindOf(PseudoState) implies 
    ((self.target.oclAsType(PseudoState).kind = #join) implies 
       ((self.guard->isEmpty) and (self.trigger->isEmpty)))


-- [3] A fork segment should always target a state. 

-- STATE: Ok

inv Transition3:
  (self.stateMachine->notEmpty) implies 
    self.source.oclIsKindOf(PseudoState) implies 
      ((self.source.oclAsType(PseudoState).kind = #fork) implies
        (self.target.oclIsKindOf(State)))

-- [4] A join segment should always originate from a state.

-- STATE: Ok

inv Transition4:
  (self.stateMachine->notEmpty) implies 
    self.target.oclIsKindOf(PseudoState) implies 
      ((self.target.oclAsType(PseudoState).kind = #join) implies 
         (self.source.oclIsKindOf(State)))

-- [5] Transitions outgoing pseudostates may not have a trigger.

-- STATE: E1

inv Transition5:
  self.source.oclIsKindOf(PseudoState) 
    implies (self.trigger->isEmpty) 

-- [6] Join segments should originate from orthogonal states.

-- STATE: Ok

inv Transition6:
  self.target.oclIsKindOf(PseudoState) implies
    ((self.target.oclAsType(PseudoState).kind = #join) implies
      (self.source.container.isConcurrent))

-- [7] Fork segments should target orthogonal states.

-- STATE: E4.5: isComposite

inv Transition7:
  self.source.oclIsKindOf(PseudoState) implies
    ((self.source.oclAsType(PseudoState).kind = #fork) implies
      (self.target.container.isDefined()))

-- [8] An initial transition at the topmost level may have a trigger
-- with the stereotype "create." An initial transition of a
-- StateMachine modeling a behavioral feature has a CallEvent trigger
-- associated with that BehavioralFeature. Apart from these cases, an
-- initial transition never has a trigger.

inv Transition8:
  self.source.oclIsKindOf(PseudoState) implies
    ((self.source.oclAsType(PseudoState).kind = #initial) implies
      (self.trigger->isUndefined() or
      ((self.source.container = self.stateMachine.top) and
        (self.trigger.stereotype.name = 'create')) or
          (self.stateMachine.context_.oclIsKindOf(BehavioralFeature) and
            self.trigger.oclIsKindOf(CallEvent) and
            (self.trigger.oclAsType(CallEvent).operation = self.stateMachine.context_))
           ))


-----------------------
-- 2-13 Activity Graphs
-----------------------

context ActivityGraph

-- [1] An ActivityGraph specifies the dynamics of (i) a Package, or
-- (ii) a Classifier (including UseCase), or (iii) a
-- BehavioralFeature.

-- STATE: Ok

inv ActivityGraph1:
  (self.context_.oclIsTypeOf(Package) xor
   self.context_.oclIsKindOf(Classifier) xor
   self.context_.oclIsKindOf(BehavioralFeature))

context ActionState

-- [1] An action state has a non-empty entry action.

-- STATE: Ok

inv ActionState1:
  self.entry->size > 0

-- [2] An action state does not have an internal transition, exit
-- action, or a do activity.

-- STATE: E1: internalTransition

inv ActionState2:
  self.internal->size = 0 and self.exit->size = 0 and 
  self.doActivity->size = 0

-- [3] Transitions originating from an action state have no trigger
-- event.

-- STATE: E1: internalTransition, I1.6

inv ActionState3:
  self.outgoing->forAll(t | t.trigger->size = 0)


context CallState

-- [1] The entry action of a call state is a single call action.

-- STATE: Ok

inv CallState1:
  self.entry->size = 1 and self.entry.oclIsKindOf(CallAction)


context ObjectFlowState

-- [1] Parameters of an object flow state must have a type and
-- direction compatible with classifier or classifier-in-state of the
-- object flow state.

-- STATE: E1: .forAll, E2.3: allSupertypes, E4.5: parameter.kind

inv ObjectFlowState1:
  self.parameter->forAll(p |
    type = self.osftype()
    or (p.kind = #in_
       and self.osftype().allParents()->includes(type))
    or ((p.kind = #out or p.kind = #return)
       and type.allParents()->includes(self.osftype()))
    or (p.kind = #inout
      and ( self.osftype().allParents()->includes(type)
        or type.allParents()->includes(self.osftype()))))

-- [2] Downstream states have entry actions that accept input
-- conforming to the type of the classifier or
-- classifier-in-state. The entry actions use the input parameters of
-- the object flow state. Valid downstream states are calculated by
-- traversing outgoing transitions transitively, skipping pseudo
-- states, and entering and exiting subactivity states, looking for
-- regular states. If the object flow state has no parameters, then
-- the target of downstream actions must conform to the type of the
-- classifier or classifier-in-state.

-- STATE: E1: .forAll, E2.3: allnextleafstates, E4.1

inv ObjectFlowState2:
  true
--   self.allnextleafstates.size > 0 and
--     self.allnextleafstates->forAll(self.isinputaction(entry))

-- [3] Upstream states have entry actions that provide output or
-- return values conforming to the type of the classifier or
-- classifier-in-state. The entry actions use the output or return
-- parameters of the object flow state. Valid upstream states are
-- calculated by traversing incoming transitions transitively,
-- skipping pseudo states, entering and exiting subactivity states,
-- looking for regular states.

-- STATE: E1: .forAll, E2.3: allpreviousleafstates, E4.1

inv ObjectFlowState3:
  true
--   self.allpreviousleafstates.size > 0 and
--     self.allpreviousleafstates.forAll(self.isoutputaction(entry))


context PseudoState

-- [1] In activity graphs, transitions incoming to (and outgoing from)
-- join and fork pseudostates have as sources (targets) any state
-- vertex. That is, joins and forks are syntactically not restricted
-- to be used in combination with composite states, as is the case in
-- state machines.

-- STATE: E4.5: added self.container, I1.6

inv Pseudostate1:
  self.container.stateMachine.oclIsTypeOf(ActivityGraph) implies
    ((self.kind = #join or self.kind = #fork) implies
      (self.incoming->forAll(t | t.source.oclIsKindOf(State) or
        t.source.oclIsTypeOf(PseudoState)) and
      (self.outgoing->forAll(t | t.source.oclIsKindOf(State) or
        t.source.oclIsTypeOf(PseudoState)))))


------------------------
-- 2-14 Model Management
------------------------

context Package

-- [1] A Package may only own or reference Packages, Classifiers,
-- Associations, Generalizations, Dependencies, Constraints,
-- Collaborations, StateMachines, and Stereotypes.

-- STATE: Ok

inv Package1:
  self.contents()->forAll ( c |
    c.oclIsKindOf(Package) or
    c.oclIsKindOf(Classifier) or
    c.oclIsKindOf(Association) or
    c.oclIsKindOf(Generalization) or
    c.oclIsKindOf(Dependency) or
    c.oclIsKindOf(Constraint) or
    c.oclIsKindOf(Collaboration) or
    c.oclIsKindOf(StateMachine) or
    c.oclIsKindOf(Stereotype) )

-- [2] No imported element (excluding Association) may have the same
-- name or alias as any element owned by the Package or one of its
-- supertypes.

-- STATE: E0.1

inv Package2:
  true
--   self.allImportedElements->reject( re |
--     re.oclIsKindOf(Association) )->forAll( re |
--       (re.elementImport.alias <> '' implies
--         not (self.allContents - self.allImportedElements)->
--           reject( ve |
--             ve.oclIsKindOf (Association) )->exists ( ve |
--               ve.name = re.elementImport.alias))
--       and
--       (re.elementImport.alias = '' implies
--         not (self.allContents - self.allImportedElements)->
--           reject ( ve |
--             ve.oclIsKindOf (Association) )->exists ( ve |
--               ve.name = re.name) ) )


-- [3] Imported elements (excluding Association) may not have the same
-- name or alias.

-- STATE: E0.1

inv Package3:
  true
--   self.allImportedElements->reject( re |
--     not re.oclIsKindOf (Association) )->forAll( r1, r2 |
--       (r1.elementImport.alias <> '' and
--         r2.elementImport.alias <> '' and
--         r1.elementImport.alias = r2.elementImport.alias
--         implies r1 = r2)
--       and
--       (r1.elementImport.alias = '' and
--         r2.elementImport.alias = '' and
--         r1.name = r2.name implies r1 = r2)
--       and
--       (r1.elementImport.alias <> '' and
--         r2.elementImport.alias = '' implies
--           r1.elementImport.alias <> r2.name))


-- [4] No imported element (Association) may have the same name or
-- alias combined with the same set of associated Classifiers as any
-- Association owned by the Package or one of its supertypes.

-- STATE: E0.1

inv Package4:
  true
--   self.allImportedElements->select( re |
--     re.oclIsKindOf(Association) )->forAll( re |
--       (re.elementImport.alias <> '' implies
--         not (self.allContents - self.allImportedElements)->
--         select( ve |
--           ve.oclIsKindOf(Association) )->exists(
--           ve : Association |
--             ve.name = re.elementImport.alias
--             and
--             ve.connection->size = re.connection->size and
--             Sequence {1..re.connection->size}->forAll( i |
--               re.connection->at(i).type =
--               ve.connection->at(i).type ) ) )
--       and
--       (re.elementImport.alias = '' implies
--         not (self.allContents - self.allImportedElements)->
--         select( ve |
--           not ve.oclIsKindOf(Association) )->exists( ve :
--           Association |
--             ve.name = re.name
--             and
--             ve.connection->size = re.connection->size and
--             Sequence {1..re.connection->size}->forAll( i |
--               re.connection->at(i).type =
--               ve.connection->at(i).type ) ) ) )

-- [5] Imported elements (Association) may not have the same name or
-- alias combined with the same set of associated Classifiers.

-- STATE: E0.1

inv Package5:
  true
--   self.allImportedElements->select ( re |
--     re.oclIsKindOf (Association) )->forAll ( r1, r2 : Association |
--       (r1.connection->size = r2.connection->size and
--       Sequence {1..r1.connection->size}->forAll ( i |
--         r1.connection->at (i).type =
--           r2.connection->at (i).type and
--         r1.elementImport.alias <> '' and
--         r2.elementImport.alias <> '' and
--         r1.elementImport.alias = r2.elementImport.alias
--         implies r1 = r2))
--       and
--       (r1.connection->size = r2.connection->size and
--         Sequence {1..r1.connection->size}->forAll ( i |
--           r1.connection->at (i).type =
--             r2.connection->at (i).type and
--           r1.elementImport.alias = '' and
--           r2.elementImport.alias = '' and
--           r1.name = r2.name
--           implies r1 = r2))
--       and
--       (r1.connection->size = r2.connection->size and
--       Sequence {1..r1.connection->size}->forAll ( i |
--         r1.connection->at (i).type =
--           r2.connection->at (i).type and
--         r1.elementImport.alias <> '' and
--         r2.elementImport.alias = ''
--         implies r1.elementImport.alias <> r2.name)))

context Subsystem

-- [1] For each Operation in an Interface offered by a Subsystem, the
-- Subsystem itself or at least one contained specification element
-- must have a matching Operation.

-- STATE: E0.2, I1.1

inv Subsystem1:
  true
--   self.specification()->collect(c | c.allOperations())->flatten->forAll(interOp |
--     self.allOperations()->union (self.allSpecificationElements()->select(specEl|
--       specEl.oclIsKindOf(Classifier))->forAll(c|
--         c.allOperations))->exists
--           ( op | op.hasSameSignature(interOp) ) )


-- [2] The Features of a Subsystem may only be Operations or
-- Receptions.

-- STATE: Ok

inv Subsystem2:
  self.feature->forAll(f | f.oclIsKindOf(Operation) or
    f.oclIsKindOf(Reception))


--------------------------------------------------------------
-- package Identity_and_snapshot
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------

context Change

-- Execution Rules
-- [1] If a change has both predecessor and successor snapshots,
-- then they must have the same identity.
  inv Change_snapshot_consistency:
    self.predecessor.isDefined() and self.successor.isDefined() implies
    self.predecessor.identity = self.successor.identity
-- [2] A change must have a predecessor or a successor (or both) and
-- must be part of a single list of changes in the same history.
  inv Change_history_consistency:
--    (self.predecessor.isDefined() or self.successor.isDefined())   and
--    (self.predecessor.isUndefined() or
--       self.predecessor.successor() = self and self.predecessor.history = self.history) and
--    (self.successor.isUndefined() or
--       self.successor.predecessor() = self and self.successor.history = self.history)
    (self.predecessor.isDefined() or self.successor.isDefined())   and
    (self.predecessor.isUndefined() or
     self.predecessor.postChange = self and self.predecessor.preChange.history = self.history) and
    (self.successor.isUndefined() or
     self.successor.preChange = self and self.successor.postChange.history = self.history)
-- [3] A change cannot have a time that is earlier than the time of its
-- predecessor.
  inv Time_ordering_consistency:
    not self.predecessor.isDefined() or self.predecessor.preChange.time <= self.time

context ExecutionSnapshot

-- Execution Rules
-- [1] Execution-step constraint. The pre- and post-changes of
-- an execution snapshot are both steps.
  inv Execution_step:
    self.preChange.oclIsKindOf(Step) and self.postChange.oclIsKindOf(Step)

context History

-- Wellformedness Rules
-- [1] History consistency. A history has one creation change
-- and one destruction change.
  inv History_consistency:
    self.change->select(c:Change|not c.predecessor.isDefined())->size() = 1 and
    self.change->select(c:Change|not c.successor.isDefined())->size() = 1

context Step
-- Execution Rules
-- [1] Step-snapshot consistency. The predecessor and successor
-- snapshots of a step must be execution snapshots.
inv Step_consistency:
    self.predecessor.oclIsKindOf(ExecutionSnapshot) and
    self.successor.oclIsKindOf(ExecutionSnapshot)
--------------------------------------------------------------
-- package object execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------
context AttributeValue

-- Execution Rules
-- [1] Attribute ordering consistency. An attribute value may only have a predecessor
-- or successor if its attribute is ordered. If it has a predecessor or successor,
-- then it must be part of a list of attribute values for the same attribute.
inv OrderingConsistency:
-- FIXME: `ordering' is neither an attribute of class `Attribute' nor a role
-- name reachable from this class.
-- (self.attribute_.ordering = #unordered implies
--    self.predecessor.isUndefined() and self.successor.isUndefined()) and
 (self.predecessor.isUndefined() or
 (self.predecessor<>self and self.predecessor.attribute_=self.attribute_ and
  self.predecessor.successor=self)) and
(self.successor.isUndefined() or
 (self.successor<>self and self.successor.attribute_=self.attribute_ and
  self.successor.predecessor=self))

context ObjectSnapshot

-- Execution Rules
-- [1] Object-identity constraint. The identity of an object snapshot must be an object identity.
inv objectID:
  self.identity.oclIsKindOf(ObjectIdentity) and
  self.objectId = self.identity.oclAsType(ObjectIdentity)

-- [2] Attribute conformance. For each attribute owned by each classifier of an object snapshot,
-- there must be a number of attribute values conforming to the multiplicity of the attribute
-- and the instance-identity value of these attribute values must all be distinct.
-- If an attribute is ordered, then all the attribute values for that attribute must be linked
-- together in a single predecessor/successor list.
-- inv attributeConformance:
-- FIXME: Undefined operation named `allAttributes' in expression `Set(Classifier).allAttributes()'.
--   self.classifier.allAttributes->forAll(a : Attribute |
--     a.multiplicity.allows(self.attributeValue->select(attribute = a)->size()) and
--     self.attributeValue->select(attribute = a)->
--       isUnique(self.attributeValue->select(attribute = a)) and
--    (a.ordering = #ordered_ implies
--      self.attributeValue->select(attribute = a)->select(predecessor.isUndefined()).size()<=1 and
--      self.attributeValue->select(attribute = a)->select(successor.isUndefined()).size()<=1))

-- [3] Association conformance. For each association in which a classifier of an object
-- snapshot is involved, for each navigable opposite association end of the association,
-- for each distinct set of values for qualifiers of that association end (if any) there
-- must be a number of link-end values consistent with the multiplicity of that association
-- end and the instance-identity values of those link-end values must be distinct.
-- inv associationConformance:
--  self.classifier.allAssociations->forAll(a:Association|a.connection->
--    forAll(ae:AssociationEnd|ae.allOppositeAssociationEnds->
--      select(ae2:AssociationEnd|ae2.isNavigable)->
--        forAll(ae2:AssociationEnd| ae2.multiplicity.allows(self.linkEndValue->
--          select(lev:LinkEndValue|lev.associationEnd = ae2)->size()) and
--          self.linkEndValue select(lev:LinkEndValue|lev.associationEnd = ae2)->isUnique(value)

--------------------------------------------------------------
-- package link execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------

context LinkEndValue

-- Execution Rules
-- [1] Association-end ordering consistency. A link-end value may only have a
-- predecessor or successor if its association end is ordered. If it does have a
-- predecessor or successor, then it must be a part of a linked list of link-end
-- values for the same association end but different links.
  inv orderingConsistendcy:
   (self.associationEnd.ordering = #unordered implies
    self.predecessor->isUndefined() and self.successor->isUndefined()) and
   (self.predecessor->isUndefined() or self.predecessor.successor=self) and
   (self.successor->isUndefined() or self.successor.predecessor=self) and
    Set{self.predecessor}->union(Set{self.successor})->
      forAll(associationEnd=self.associationEnd and link<>self.link)
-- [2] Qualifier conformance. For each qualifier of the association end of a link-end
-- value, the link-end value must have a number of attribute values for that qualifier
-- allowed by the multiplicity of the qualifier and the instance-identity
-- values of those attribute values must all be distinct.
--  inv qualifierConformance:
-- FIXME: Undefined operation named `isUnique' in expression `Set(AttributeValue).isUnique(InstanceIdentity)'.
--    self.associationEnd.qualifier->forAll(q : Attribute |
--      q.multiplicity.allows(self.qualifierValue->
--        select(av:AttributeValue|av.attribute_  = q)->size()) and
--      self.qualifierValue->select(av:AttributeValue|av.attribute_ = q)->isUnique(value))

-- context LinkIdentity
-- Execution Rules
--  inv Association_end_conformance:
-- [1] Association-end conformance. Each link-end value of a link identity must be for
-- a distinct association end of the association of the link identity and each
-- non-optional association end (i.e., one with a multiplicity lower bound
-- greater than zero) must have a corresponding link-end value.
--  self.linkEndValue.associationEnd->isUnique(ae: AssociationEnd | ae) and
-- FIXME: Undefined operation named `associationEnd' in expression
-- 'Set(LinkEndValue).associationEnd()'.
--  self.linkEndValue.associationEnd = self.association_.connection

context LinkSnapshot
-- Execution Rules
  inv Link_identity_constraint:
-- [1] Link-identity constraint. The identity of a link snapshot must be a link identity.
  self.identity.oclIsKindOf(LinkIdentity) and self.linkId = self.identity.oclAsType(LinkIdentity)

--------------------------------------------------------------
-- package link objects
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------
context LinkObjectSnapshot
-- Execution Rules
-- [1] Link-object-identity constraint. The identity of a link-object snapshot
-- must be a link-object identity.
  inv Link_object_identity_constraint:
    self.identity.oclIsKindOf(LinkObjectIdentity)

-- [2] Association-class conformance. Exactly one of the classifiers of a
-- link-object snapshot must be an association class that is the same
-- as the association related to its identity.
  inv Association_class_conformance:
  self.linkId.association_.oclIsKindOf(AssociationClass) and
  self.classifier->count(self.linkId.association_.oclAsType(AssociationClass)) = 1

--------------------------------------------------------------
-- package classifier extent
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------
context ClassifierExtentSnapshot
-- Execution Rules
-- [1] Classifier-extent-identity constraint. The identity of an
-- classifier-extent snapshot must be an classifier-extent identity.
  inv Classifier_extent_identity_constraint:
  self.identity.oclIsKindOf(AssociationExtentIdentity) and
  self.extentId=self.identity.oclAsType(ClassifierExtentIdentity)

--------------------------------------------------------------
-- package association extent
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------
context AssociationExtentSnapshot
-- Execution Rules
-- [1] Association-extent-identity constraint. The identity of an
-- association-extent snapshot must be an association-extent identity.
  inv Association_extent_identity_constraint:
  self.identity.oclIsKindOf(AssociationExtentIdentity) and
  self.extentId = self.identity.oclAsType(AssociationExtentIdentity)
-- [2] Association-extent conformance. All links of an association-extent
-- snapshot must have the same association as the extent.
  inv Association_extent_conformance:
  self.link->forAll(l:LinkIdentity| l.association_ = self.extentId.association_)
-- [3] Link uniqueness. No two links in an association-extent snapshot can
-- have identical values for all link-ends and qualifiers.
  inv Link_uniqueness:
  self.link->forAll(l1, l2 : LinkIdentity |
                    l1.linkEndValue->collect(lev:LinkEndValue|lev.value) =
                    l2.linkEndValue->collect(lev:LinkEndValue|lev.value) and
                    l1.linkEndValue->collect(lev:LinkEndValue|lev.qualifierValue) =
                    l2.linkEndValue->collect(lev:LinkEndValue|lev.qualifierValue) implies
                    l1 = l2)
-- [4] Association-multiplicity conformance. The set of links of an
-- association-extent snapshot must conform to the multiplicity of each of
-- the association ends of the association of the extent.
-- Note. OCL to be done.
--------------------------------------------------------------
-- package state machine execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- contraints
--------------------------------------------------------------

context StateMachineExecutionIdentity
-- Well-formedness Rules
-- [1] State-machine occurrence consistency. The events of an occurrence
-- associated with a state-machine-execution identity must be from the state
-- machine for that identity.
-- FIXME: association occurrence not drawn in the figure 13.
  inv State_machine_occurrence_consistency:
  self.occurrence->collect(o:Occurrence|o.event)->flatten->
                           forAll(event : Event | self.machine.allTransitions()->
                                  collect(t:Transition| t.trigger) ->includes(event))

context StateMachineExecutionSnapshot
-- Well-formedness Rules
-- [1] Current-occurrence consistency. The current occurrence of a state-machine-execution
-- snapshot must be in the set of occurrence receptions of the state-machine-execution
-- identity of the snapshot.
-- FIXME: association occurrence not drawn in the figure 13.
  inv Current_occurrence_consistency:
  self.executionId.occurrence->includes(self.current)
-- [2] State_machine_conformance. The configuration of a state-machine-execution snapshot
-- must include the top state of the state machine of the identity of the execution
-- snapshot. All the other states in the configuration must be contained,
-- directly or indirectly, in this top state.
  inv State_machine_conformance:
  self.configuration->includes(self.executionId.machine.top) and
  self.configuration->forAll(s:State | s <>self.executionId.machine.top implies
    self.executionId.machine.top.allSubstates()->includes(s))

--------------------------------------------------------------
-- package occurrence
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- contraints
--------------------------------------------------------------

context ChangeOccurrence
-- Well-formedness Rules
-- [1] Change-event conformance. All the events of a change occurrence must be change events.
  inv Change_event_conformance:
  self.event->forAll(event | event.oclIsKindOf(ChangeEvent))
-- [2] A change occurrence has no arguments.
  inv No_arguments:
  self.argument->isEmpty

--context SignalOccurrence
-- Well-formedness Rules
-- [1] Signal-event conformance.
-- FIXME: asSequence not implemented
--  inv Signal_event_conformance:
--  self.signalInstance.classifier->size = 1 and
--  self.signalInstance.classifier->asSequence->first.oclIsKindOf(Signal) and
--  self.event->forAll(e:Event | e.oclIsKindOf(SignalEvent) and
--  e.oclAsType(SignalEvent).signal.allSupertypes->
--    includes(self.signalInstance.classifier->asSequence->first)) and
--  self.argument = self.signalInstance.attributeValue.value

context TimeOccurrence
-- [1] Time-event conformance. All the events of a time occurrence must be time events.
  inv Time_event_conformance:
  self.event->forAll(e:Event | e.oclIsKindOf(TimeEvent))

-- [2] A time occurrence has no arguments.
  inv NoArguments:
  self.argument->isEmpty
--------------------------------------------------------------
-- package Action Foundation
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------
context Action_
-- Well-formedness rules
--[1] There must be no cycles in the graph of actions and flows
  inv no_cycles:
  not self.allSuccessors()->includes(self)

context DataFlow
-- Well-formedness rules
-- [1] The type of the source pin must be the same as or a descendant of the type
-- of the destination pin
  inv same_type:
  not self.destination.type.isDefined() or
  (self.source.type.isDefined() and self.source.type = self.destination.type or
   self.destination.type.allParents()->includes(self.source.type))

context InputPin
-- Well-formedness rules
-- [1] An input pin must be owned by either an action or a procedure but not both.
  inv input_action_xor_proc:
  self.action->isDefined() xor self.procedure1->isDefined()

context OutputPin
-- Well-formedness rules
-- [1] An output pin must be owned by either an action or a procedure but not both.
  inv output_action_xor_proc:
  self.action->isDefined() xor self.procedure1->isDefined()

context PrimitiveAction
-- Well-formedness rules
-- [1] The available inputs of a primitive action are the input pins of the action.
  inv availableinputs:
  self.availableInput = self.inputPin->asSet()
-- [2] The available outputs of a primitive action are the output pins of the action.
  inv availableoutputs:
  self.availableOutput = self.outputPin->asSet()

context Procedure
-- Well-formedness rules
-- [1] All available inputs of the action of a procedure must be the destinations of flows,
-- the sources of which are arguments of the procedure.
  inv available_inputs:
  self.argument->asSet()->includesAll(self.action.availableInput->collect(i:InputPin|i.flow.source)->asSet)
-- [2] All results of a procedure must be the destination of flows, the sources of which
-- are available outputs of the action of the procedure.
  inv results:
  self.action.availableOutput->includesAll(self.result->collect(i:InputPin|i.flow.source)->asSet)
--------------------------------------------------------------
-- package action foundation execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------

-- context ActionExecutionIdentity
-- Well-formedness rules
--   inv _AEI_context_xor_parent:
-- [1] An action-execution snapshot must have either a context or a parent, but not both.
--   self._context.isDefined() xor self.parent.isDefined()

context ActionExecutionSnapshot
-- Well-formedness rules
-- [1] The identity of an action-execution snapshot must be an action-execution identity.
  inv ActionExecution_identities:
  self.identity.oclIsKindOf(ActionExecutionIdentity) and
  executionID=self.identity.oclAsType(ActionExecutionIdentity)

context PinValue
-- Well-formedness rules
-- [1] The number of values of a pin value must be consistent with the
-- multiplicity of the pin of the pin value.
  inv number_of_values:
  self.pin.multiplicity.allows(self.value->size())

context PrimitiveActionExecutionIdentity
-- Well-formedness rules
-- [1] The action of a primitive-action execution identity must be a primitive action.
  inv action_of_execution:
  self.action.oclIsKindOf(PrimitiveAction)

context ProcedureExecutionIdentity
-- Well-formedness rules
-- [1] The action execution nested in a procedure-execution identity must be for
-- the action of the procedure.
  inv nested_action:
  self.actionExecution.action=self.procedure1.action

context ProcedureExecutionSnapshot
-- Well-formedness rules
-- [1] The identity of a procedure-execution snapshot must be a procedure-execution identity.
  inv procexecsnapidentities:
  self.identity.oclIsKindOf(ProcedureExecutionIdentity) and
  self.executionID=self.identity.oclAsType(ProcedureExecutionIdentity)

--------------------------------------------------------------
-- package composite action
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------

context GroupExecutionIdentity
-- Wellformedness Rules
-- [1] The action of a group-execution identity must be a group action.
  inv ActionForGroupAction:
  self.action.oclIsKindOf(GroupAction)
-- [2] A group-execution identity must have one unique subaction execution
-- for each subaction of its group action.
  inv unique_subaction:
--  self.subactionExecution->isUnique(aei:ActionExecutionIdentity|aei.action) and
  self.subactionExecution->collect(aei:ActionExecutionIdentity|aei.action)->
                                   forAll(e1,e2| e1 <> e2) and
  self.subactionExecution->collect(aei:ActionExecutionIdentity|aei.action)->asSet() =
  self.action.oclAsType(GroupAction).subaction
-- [3] The subaction executions of a group-execution identity have
-- the group-execution identity as their parent.
-- FIXME: Undefined identifier `parent'. Expected a variable, an attribute or an operation
-- I am afraid that the problem here is that self.parent is supossed to return the
-- parent action of the current action and it returns the set of all direct parent classes.
--  inv parent_identity:
--  self.subactionExecution->forAll(parent=self)

context GroupExecutionSnapshot
-- Wellformedness Rules
-- [1] The identity of a group-execution snapshot must be a group-execution identity.
  inv group_execution_identity:
  self.identity.oclIsKindOf(GroupExecutionIdentity) and
  self.groupExecutionID = self.identity.oclAsType(GroupExecutionIdentity)
-- Lifecycle
-- Production 1: When a group executes, it executes all its subactions and variables.
-- Precondition: self.status = #ready
-- Postcondition: self.status = #executing and self.subactionExecutionsStarted() and
-- self.variableExecutionsStarted()
-- Production 2: A group execution completes when all its subaction executions have
-- completed, which causes its variable executions to complete.
-- Precondition: self.status = #executing
-- Postcondition: self.subactionExecutionsCompleted() and
-- self.status = #complete and self.variableExecutionsStopped()

--------------------------------------------------------------
-- package composite action execution
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------

context VariableExecutionSnapshot
-- Wellformedness Rules
-- [1] The identity of a variable-execution snapshot must be a variable-execution identity.
  inv variable_execution_identity:
  self.identity.oclIsKindOf(VariableExecutionIdentity) and
  self.executionID = self.identity.oclAsType(VariableExecutionIdentity)
-- [2] The number of values of a variable-execution snapshot must be consistent
-- with the multiplicity of the variable of the snapshot.

-- Commented out by MR (due to problems probably resulting from
-- renaming conflicting rolenames)
--  inv consistent_number_values:
--  self.executionID.variable.multiplicity.allows(self.value->size())

--------------------------------------------------------------
-- package Computation actions. Apply function action
-- Modeled after definition in Response to OMG RFP ad/98-11-01
-- U. of York. October 2000
-- Jose Alvarez
--------------------------------------------------------------
-- constraints
--------------------------------------------------------------

context ApplyFunctionAction
-- Well-formedness rules
-- [1] The number and types of the input argument and output result pins
-- must be compatible with the number and types of the parameters of the function.
  inv compatible_pins:
  self.argument->size() = self.function.inputType->size()

-- Sequence {1..self.input_argument()->size( )} -> forAll (i:Integer |
-- let argumenti = self.input_argument (i)
-- let inparameteri = self.function.inputType->at(i)
-- argumenti.type.isCompatibleWith (inparameteri.type))
-- self.output_result()->size( ) = self.function.outputType->size( )
-- Sequence {1..self.output_result()->size( )} -> forAll (i:Integer |
-- let resulti = self.output_result (i)
-- let outparameteri = self.function.outputType->at(i)
-- outparameteri.type.isCompatibleWith (resulti.type))
